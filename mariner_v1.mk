#############
# Table of contents:
#  - Intro
#  - Global setup
#  - API  ("do_mariner()")
#  - Pre-processing #1: schema parsing
#  - Pre-processing #2: dynamic rule generation
#  - Recipe-time functions
#############

#############
# Intro
#
# The user supplies a makefile that defines their use-case (typically
# GNUmakefle, seeing as this functionality is specific to GNU make), includes
# this file, and then invokes the do_mariner() API to produce all the rules,
# dependencies and other obscure machinery. If the user wishes to override some
# of the global settings, they should do so after including this file and
# before invoking the API.
#
# Some notes about docker. The whole premise for this system is to create a
# simple and flexible workflow for development, using docker to allow each
# "unit" of development to have its own operating environment, and leveraging
# docker's filesystem smarts to allow those environments to share as much or as
# little as required. Docker already has a very strong notion of inheritence
# and dependency, through the strict and simple semantic that each Dockerfile
# must begin with exactly one "FROM" command - which defines the new container
# image as being a derivative of another, underlying container image. We
# leverage and align to that relationship in the following ways;
# - the Dockerfile associated with each of the user's specified container
#   images is respected and used exactly as-is with one critical exception; it
#   must NOT have a FROM command.
# - the user's GNUmakefile, when declaring container images, must give each
#   image either a _TERMINATE or _EXTENDS attribute.
#   - _TERMINATE indicates that the user's image is derived from an
#     external/upstream image, i.e. outside this mariner environment, from
#     dockerhub or some other docker registry.
#   - _EXTENDS indicates that the user's image is derived from another of the
#     user's images, and this creates the association between docker's notion
#     of inheritence and the makefile dependencies generated by mariner.
# - container images get built by automatically prepending the user's
#   Dockerfile with a "FROM" line that is determined from _TERMINATE/_EXTENDS
#   settings.
#
# The rest of the information in this file is about _how_ this works, i.e.
# implementation. For more info on the UX, look at the example GNUmakefile(s)
# and the "documentation" therein. Also, "make" (i.e. "make default") will spit
# out a list of the most important commands, and "make dump" can also provide
# some insights. If your shell has tab-completion support for GNU make, which
# is now quite common, you can also that to explore the available targets
# alphabetically.
#
# Dev notes;
#
# After gmake has loaded/read/parsed all the raw makefile content (GNUmakefile
# and anything that gets included from there), and _before_ gmake pays any
# attention to the targets that the user requested be "made", it does a pass
# over the loaded makefile content to do expansion. This pass is (for our
# purposes) like a preprocessor, where "expansion" actually provides us with
# the programmatic equivalent of a precompiler, so long as we make abundant use
# of the $(eval) construct (I'll get to that in a moment).
#
# This expansion/precompilation can dynamically generate makefile content,
# in-place, that will get treated exactly as though it was there in the
# original makefile when it comes time to process the user's requested targets.
# All of this preprocessing and inline expansion is encapsulated in the
# "do_mariner" API that the user invokes from their GNUmakefile using;
#   $(eval $(call do_mariner))"
#
# Once _that_ is done, gmake proceeds to examine the targets requested by the
# user, and track through all the rules/dependencies/recipes (irrespective of
# whether they were statically defined or dynamically generated). The makefile
# rules that do_mariner() dynamically generates include some programmatic
# elements in their recipes. These need to survive preprocessing expansion "as
# text, not code", so that gmake will only process/execute them later, if/when
# those generated recipes get run because their rule-dependencies got
# triggered. I call this generated/late-execution code "recipe-time logic", to
# distinguish it from "preprocessor logic". (This may be imprecise, and
# apologies to GNU make hackers if so, but it gets me through the day.)
#
# One more consideration/requirement before explaining the structure of the
# code. The schema filled out by the user, which is rooted in whatever they put
# into the IMAGES variable (and which in turn "points" to all the other
# data/state that we use), holistically determines all the inter-dependencies,
# orderings, and parameters. Past experience has shown that sanity is best
# preserved if one first parses and digests _all_ that input before trying to
# output _any_ dynamically-generated content. So in the "preprocessing" (or
# precompilation) phase, we want to run two clearly distinct phases of
# processing; first the parsing of all the _input_ (plus building up the
# internal data and making some logical determinations), and second the
# generation of the resulting _output_ makefile elements. Together, this
# preprocessing implements "a make system". (Tab-completion scripts typically
# use "make -pqnr"-style output, after preprocessing has occurred, so
# tab-completion sees the results of all this, which works quite nicely.)
#
# The above motivates the break-down of the code and the discipline that attempts
# to keep it comprehensible and manageable.
#
# - Preprocessing, all of which is characterized by the uniquitous use of the
#   $(eval) construct.
#
#   * Global setup
#     - This sets up global variables that the user can override. I.e. after
#       including this file but before invoking the do_mariner() API.
#     - We use ":=" (not "=", which can inadvertently define macros for later
#       expansion/evaluation, rather than the immediate-evaluation behavior we
#       need).
#
#   * API
#     - This is the all-encompassing do_mariner() API, which in fact does
#       nothing other than to invoke the functions that implement the remaining
#       preprocessing steps in order.
#
#   * Schema parsing
#     - The do_parse() function wraps all of the subsidiary work of reading
#       inputs and following our noses to other inputs, which results in the
#       build up of the state required to generate the corresponding makefile
#       rules.
#     - All other functions in this section are prefixed with "parse_".
#     - All logic in this section should fully expand/evaluate during
#       preprocessing, so use of $(eval) is ubiquitous.
#     - In addition to the user's makefile inputs (IMAGES, etc), this
#       processing also interogates the file-system. This is primarily used to
#       tweak the way "delete" rules should be created later on;
#       a so that interdependencies between things _that exist_ can be
#         expressed, ensuring they are deleted in the required sequence,
#       b so that interdependencies do _not_ get created for things that
#         haven't been created (or have previously been deleted), otherwise
#         deletes may cause creations.
#       c to handle the case where a non-empty volume can't be emptied by the
#         make system directly, but needs to be emptied from within a container
#         that mounts it. (Namespaces are weird.)
#       In the special case that combines b and c, it can even happen that a
#       delete rule simply needs to fail gracefully. I.e. when a volume needs
#       to be emptied before it can be deleted, and the container that supports
#       that ability has itself already been deleted. The preprocessing logic
#       detects this situation and produces delete rules that provide
#       information and hints.
#
#   * Dynamic rule generation
#     - The do_gen() function wraps all of the subsidiary work of emitting
#       makefile output.
#     - All other functions in this section are prefixed with "gen_".
#     - This is the only section that can/should mix preprocessing logic, as
#       expanded early through an unbroken chain of $(eval) constructs, and
#       recipe-time logic, which is _not_ expanded/executed early, and so
#       survives "as text" to form the makefile output/rules. This can be seen
#       through;
#       - the lack of $(eval) constructs in some assignments and function
#         calls. This lets code "survive as text" during initial expansion.
#       - the presence of literal makefile rules in the code, which act like
#         templates that undergo some substitution before "falling through" the
#         preprocessing to form the generated makefile content.
#       - the presence of double-escaping ($$), which the preprocessor
#         collapses to single-escaping ($).
#     - The final "mdirs" code produces what should be the final rule in the
#       generated makefile content, namely the "$(MDIRS):" target. This is our
#       "create empty directory on demand" rule, that allows any prior code to
#       add directory paths to MDIRS in order for them to get this support.
#
# - Recipe-time functions
#
#   * The dynamic rule generation code runs at preprocessor-time, but produces
#     some makefile outputs that contain code (double-escaped and/or
#     non-$(eval)-invoked) to be run later, when gmake is processing
#     user-requested targets and invoking the relevant rules. Any sub-routines
#     used by that "recipe-time" code go into this section.
#
#   * To maintain the clarity that "all rules are fully baked and 'known' when
#     preprocessing completes" (which among other things gives us an excellent
#     UX w.r.t. tab-completion), we limit the recipe-time logic to stuff that
#     is _focussed on reporting on the results of the preprocessing_. Currently
#     this constitutes;
#     - a structured help screen for "make default", which lists off all the
#       images, volumes, commands, and description information that was built
#       up and produced.
#     - some debugging support for "make dump", which gives a detailed
#       structured listing of the internal data built up during preprocessing.
#       I.e. the results of the "schema parsing" phase that were consumed/used
#       by the "dynamic rule generation" phase.
#     - having this processing run explicitly at recipe-time helps seperate the
#       code that's "doing the observing" from the code that's "being
#       observed".
#
# - Some notes about conventions, style, etc;
#
#   * the only true local variables are the automatic variables ($1, $2, etc),
#     everything else is global. So if you initialize variable 'c' in a
#     function, it clobbers any higher-level function's use of 'c'.
#   * assume any single-letter variable can be clobbered by any call.
#   * other variables should be named to be globally unique.
#   * exception, $(foreach i,some_list,$(call foo,$i)) is fine, even if foo
#     internally uses 'i' for another purpose. On each exit from foo, 'i' may
#     have been clobbered but the "foreach" logic doesn't care; it will set 'i'
#     to the correct next value for the loop.
#   * before each function that needs uniqueness will be a comment of the form;
#         # uniquePrefix: <prefix>
#     In this way, this file can be grepped and sorted, so that uniqueness can
#     be verified at a glance by ensuring there are no duplicates. I've taken
#     to setting the prefix to be an acronym for the function name, with a
#     tie-break character if there's a conflict. It's getting ugly though -
#     maybe there's a smarter way.
#############


#############
# Global setup
#
# These settings can be overriden by the user's makefile, if required, at their
# risk and peril. :-)
#############

# If V is defined, make a lot more noise
ifndef V
	Q := @
endif

# Passed to "docker run".
$(eval DEFAULT_docker_run_args := --rm -a stdin -a stdout -a stderr -i -t)

# This is the default shell to use for the generic "make <image>_shell"
# command.
$(eval DEFAULT_shell := /bin/sh)

# The user supplies IMAGES, upon which everything else hangs. I.e. do_mariner()
# processes this variable and what it finds there leads it to everything else.
# The build expects to find the path to each image's source/context directory
# via the <image>_PATH attribute. If the user does not set that attribute,
# do_mariner() will set it using the default map function as defined below.
# This default implementation assumes the source path for image "foo" will be
# in $(TOPDIR)/c_foo.
# The user can optionally set DEFAULT_map to use an alternative map function.
# Note the semantics: $1 is the name of the container (from IMAGES), and the
# resulting path should be put in $1_PATH.
$(eval DEFAULT_map := mariner_default_map)
define mariner_default_map
	$(eval $(strip $1)_PATH := $(TOPDIR)/c_$(strip $1))
endef

# If a container image <foo> doesn't define <foo>_find_deps, this default will
# get used. This passes arguments to the "find $(foo_PATH)/ [...]" command, and
# whatever that returns is what we use as a dependency for rebuilding the
# container image, as well as dependencies on other container images (that we
# extend. (This command is evaluated inside the image's source directory, where
# its Dockerfile goes.)
$(eval DEFAULT_find_deps = )

# This is included by the top directory Makefile, so set a TOPDIR that can
# survive being passed around, fed into Dockerfiles, or whatever else.
$(eval TOPDIR := $(shell pwd))

# In addition to making container image builds dependent on each other and
# their respective source files (Dockerfile, etc), they should also be
# dependent on anything global at the top-level directory. This is the default
# list, it can be replaced or extended by the user in GNUmakefile.
$(eval TOP_deps := mariner_v1.mk GNUmakefile)

# VOLUMES is populated as each of the image types (and their "<foo>_VOLUMES"
# attributes) are processed. It's done this way to support the semantic whereby
# two images can specify the same volume to indicate sharing of a single
# volume.
$(eval VOLUMES := )

# Adding a directory to this variable causes a rule to be generated that allows
# the directory to be auto-created by declaring a dependency on it.
# NOTE: you usually want to specify such a dependency as _order-only_. E.g.
#
# MDIRS += $(TOPDIR)/output_dir
#
# $(TOPDIR)/output_dir/artifact: [...normal deps...] | $(TOPDIR)/output_dir
#         echo "Some output" > $(TOPDIR)/output_dir/artifact
#
# If the "|" isn't there, then "artifact" becomes dependent not just on whether
# the "output_dir" directory exists _but also on it's modification time_! If
# you don't want the "artifact" rule to fire when its normal deps are satisfied
# and the output directory exists, you need the "|". (Otherwise, if any
# unrelated activity updates the modification time of "output_dir", the
# "artifact" target will be automatically out-of-date and will fire
# needlessly.)
#
# For details, see;
# https://www.gnu.org/software/make/manual/html_node/Prerequisite-Types.html
#
# Our main use of this is for lazy-initialization of volumes for bind-mounting,
# but we create a rule to chain through that encapsulates this "|" usage. (See
# the gen_volume() function, which creates the "vol_$v_create" rule for each
# volume $v.)
$(eval MDIRS := )

#############
# API
#
# One function to rule them all, and in the darkness bind-mount them.
#
# This is the only function that should be called from the user's GNUmakefile,
# it drives everything else.
#############

define do_mariner
	$(eval $(call do_parse))
	$(eval $(call do_gen))
	$(eval $(call do_mdirs))
endef

#############
# Schema parsing
#
# We consume IMAGES and follow our noses based on what we find there, producing
# all the internal data required to "know what to do", which is then consumed
# by the subsequent post-processing steps that produce all the actual rules and
# dependencies.
#############

define do_parse
	$(foreach i,$(IMAGES),$(eval $(call parse_image,$i)))
	$(foreach i,$(VOLUMES),$(eval $(call parse_volume,$i)))
	$(eval GEN_IMG_TARGETS += create)
	$(eval GEN_IMG_TARGETS += delete)
	$(eval GEN_IMG_TARGETS += shell)
	$(eval gen_img_create_DESCRIPTION := create container image and anything it depends on)
	$(eval gen_img_delete_DESCRIPTION := delete container image and anything that depends on it)
	$(eval gen_img_shell_DESCRIPTION := start $(DEFAULT_shell) in a container)
	$(eval GEN_VOL_TARGETS += create)
	$(eval GEN_VOL_TARGETS += delete)
	$(eval gen_vol_create_DESCRIPTION := create volume)
	$(eval gen_vol_delete_DESCRIPTION := delete volume)
endef

# Called for each container image in $(IMAGES).
# uniquePrefix: pi
define parse_image
	$(eval pin := $(strip $1))
	$(eval pib := $(strip $($(pin)_VOLUMES)))
	$(eval pic := $(strip $($(pin)_COMMANDS)))
	$(if $($(pin)_PATH),,$(eval $(call $(DEFAULT_map),$(pin))))
	$(if $($(pin)_EXTENDS),
		$(eval $(call parse_image_EXTENDS,$(pin))),
		$(eval $(call parse_image_TERMINATES,$(pin))))
	$(eval $(pin)_find_deps ?= $(DEFAULT_find_deps))
	$(eval $(pin)_create_deps += \
		$(shell find $($(pin)_PATH)/ $($(pin)_find_deps)))
	$(eval $(pin)_mountdeps := \
		$(foreach i,$(pib),vol_$i_create))
	$(eval $(pin)_mountargs := \
		$(foreach i,$(pib), \
		--mount type=bind,source=$(TOPDIR)/vol_$i,destination=/$i))
	$(foreach i,$(pic),
		$(eval $(call parse_image_cmd,$(pin),$i)))
	$(foreach i,$(pib),
		$(eval VOLUMES += $(filter-out $(VOLUMES),$i)))
	$(foreach i,$(pib),
		$(eval vol_$i_image_deps += $(pin)))
endef
# uniquePrefix: pie
define parse_image_EXTENDS
	$(eval pien := $(strip $1))
	$(eval $(pien)_create_deps := .touch_c_$(strip $($(pien)_EXTENDS)))
	$(eval $(pien)_delete_deps := $(strip $($(pien)_EXTENDS))_delete)
	$(eval $(pien)_from := $($(pien)_EXTENDS))
endef
# uniquePrefix: pit
define parse_image_TERMINATES
	$(eval pitn := $(strip $1))
	$(eval $(pitn)_create_deps := $(TOP_deps))
	$(eval $(pitn)_delete_deps := )
	$(eval $(pitn)_from := $($(pitn)_TERMINATES))
endef
# uniquePrefix: pic
define parse_image_cmd
	$(eval picn := $(strip $1))
	$(eval picc := $(strip $2))
	$(eval $(picn)_$(picc)_deps := $(picn)_create $($(picn)_mountdeps))
	$(eval $1_subcommands += $(picc))
endef

# Called for each volume in $(VOLUMES).
# uniquePrefix: pv
define parse_volume
	$(eval pvn := $(strip $1))
	$(eval MDIRS += $(TOPDIR)/vol_$(pvn))
	$(eval vol_$(pvn)_create_deps := $(TOPDIR)/vol_$(pvn))
endef

#############
# Dynamic rule generation
#
# Generate rules and dependencies based on the state and understanding that was
# built up during preprocessing. This is the only section that can/should mix
# preprocessing code ($(eval) stuff) and recipe-time code (inline makefile
# rules that fall through the preprocessing to be part of the makefile output
# that applies at recipe-time).
#############

define do_gen
	$(eval $(call gen_default))
	$(eval $(call gen_dump))
	$(foreach c,$(GEN_IMG_TARGETS),$(eval $(call gen_all_img,$c)))
	$(foreach c,$(GEN_VOL_TARGETS),$(eval $(call gen_all_vol,$c)))
	$(foreach i,$(IMAGES),$(eval $(call gen_image,$i)))
	$(foreach i,$(VOLUMES),$(eval $(call gen_volume,$i)))
	$(eval $(call gen_volume_all_delete))
	$(eval $(call gen_mdirs))
endef

# Produce the default rule. This provides "usage" and performs no operations.
# Note, double-escaping ("$$") gets past the expansion of running this
# function, leaving a single escape in the generated rule. Similarly, the
# $(call)s not being wrapped in $(eval) is a symptom of the fact that the code
# here executes at "rule-time". (The functions called by this generated code
# are all in the last section, where this is described.)
define gen_default
default:
	$$Qecho
	$$Qecho "Specify a target! How many times do I have to tell you?"
	$$Qecho
	$$Qecho "Generic commands for all container images (you can use <image>=all);"
	$$(foreach i,$$(GEN_IMG_TARGETS),$$(call list_gen_img,$$i))
	$$Qecho
	$$Qecho "Container images;"
	$$(foreach i,$$(IMAGES),$$(call list_img,$$i))
	$$Qecho
	$$Qecho "Generic commands for all volumes (you can use <vol>=all);"
	$$(foreach c,$$(GEN_VOL_TARGETS),$$(call list_gen_vol,$$c))
	$$Qecho
	$$Qecho "Implied (and persistent) volumes;"
	$$(foreach v,$$(VOLUMES),$$(call list_vol,$$v))
	$$Qecho
endef

# Produce the "dump" rule. This pretty-prints out a bunch of the internal state
# that was derived during preprocessing (and that drives post-processing).
# Useful for debugging, but probably in need of improvement.
define gen_dump
dump:
	$$Qecho "Dumping for your debugging delight"
	$$Qecho
	$$(call dump_all)
endef

# Generate "all_<verb>" rules for the generic container image command in $1.
# This is just a dependency on the corresponding "<img>_<verb>" rules for each
# image.
define gen_all_img
all_$(strip $1): $(foreach i,$(IMAGES),$i_$(strip $1))
endef

# Generate "vol_all_<verb>" rules for the generic volume command in $1. This is
# just a dependency on the corresponding "<vol>_<verb>" rules for each volume.
define gen_all_vol
vol_all_$(strip $1): $(foreach v,$(VOLUMES),vol_$v_$(strip $1))
endef

# Generate rules for the container image in $1. This includes the _create,
# _delete, and _shell generics, as well as all the user-defined commands.
# Note, the dependency relationships between container images are reflected
# here in curious ways. For creation, the deps are between touchfiles. For
# deletion, the deps are between the _delete targets (rather than touchfiles)
# and they are in an inverted sense! (Makes sense if you think for a bit.)
# Also, the delete rules are generated differently depending on whether the
# container images already exist (so we don't create things in order to delete
# things).
# uniquePrefix: gi
define gen_image
	$(eval gin := $(strip $1))
	$(eval $(call gen_image_create,$(gin)))
	$(if $(wildcard .touch_c_$(gin)),
		$(eval $(call gen_image_delete,$(gin))),
		$(eval $(call gen_image_delete_null,$(gin))))
$(gin)_shell: $(gin)_create $($(gin)_mountdeps)
	$Qecho "Launching a '$(gin)' container with shell '$(DEFAULT_shell)'"
	$Qdocker run \
		$(DEFAULT_docker_run_args) \
		$($(gin)_mountargs) \
		$(gin) \
		$(DEFAULT_shell)
	$(foreach i,$($(gin)_subcommands),
		$(eval $(call gen_image_cmd,$(gin),$i)))
endef
# uniquePrefix: gic
define gen_image_create
	$(eval gicn := $(strip $1))
.touch_c_$(gicn): $($(gicn)_create_deps)
	$Qecho "(re-)Creating container image '$(gicn)'"
	$Q(( cd $($(gicn)_PATH) && \
		echo "FROM $($(gicn)_from)" > .Dockerfile.out && \
		cat Dockerfile >> .Dockerfile.out && \
		docker build -t $(gicn) -f ./.Dockerfile.out . ) && \
	touch .touch_c_$(gicn))
$(gicn)_create: .touch_c_$(gicn)
endef
# uniquePrefix: gid
define gen_image_delete
	$(eval gidn := $(strip $1))
$($(gidn)_delete_deps): $(gidn)_delete
$(gidn)_delete:
	$Qecho "Deleting container image '$(gidn)'"
	$Q((cd $($(gidn)_PATH) && \
		docker image rm $(gidn) && \
		rm .Dockerfile.out) && \
		rm .touch_c_$(gidn))
endef
# uniquePrefix: gidn
define gen_image_delete_null
	$(eval gidnn := $(strip $1))
$(gidnn)_delete:
endef
# uniquePrefix: gicm
define gen_image_cmd
	$(eval gicmn := $(strip $1))
	$(eval gicmc := $(strip $2))
$(gicmn)_$(gicmc): $($(gicmn)_$(gicmc)_deps)
	$Qecho "Launching a '$(gicmn)' container running command '$(gicmc)'"
	$Qdocker run \
		$(DEFAULT_docker_run_args) \
		$($(gicmn)_mountargs) \
		$(gicmn) \
		$($(gicmn)_$(gicmc)_COMMAND)
endef

# Generate _create and _delete rules for the volume in $1.
# _create is a rule for lazy-initialization. (We're talking bind-mounts, so by
# "initializing a volume" we simply mean "creating an empty directory". We
# explicitly mount these into containers when spinning them spun up. (I.e.
# these aren't "docker volumes" in the heavyweight sense.)
# _delete requires some messing around, depending on whether the volume exists
# (we need to treat dependencies differently), otherwise whether the user
# supplied a _WILDCARD attribute and, if they did, whether it indicates that
# the volume needs to be *emptied* before deletion and, if it does, creating a
# dependency on the corresponding hook.
# uniquePrefix: gv
define gen_volume
	$(eval gvv := $(strip $1))
	$(eval $(call gen_volume_create,$(gvv)))
	$(if $(wildcard vol_$(gvv)),
		$(eval $(call gen_volume_delete,$(gvv))),
		$(eval $(call gen_volume_delete_null,$(gvv))))
endef
# uniquePrefix: gvc
define gen_volume_create
	$(eval gvcv := $(strip $1))
vol_$(gvcv)_create: | $(vol_$(gvcv)_create_deps)
endef
# uniquePrefix: gvd
define gen_volume_delete
	$(eval gvdv := $(strip $1))
	$(if $(and $($(gvdv)_WILDCARD), $(wildcard vol_$(gvdv)/$($(gvdv)_WILDCARD))),
		$(eval $(call gen_volume_delete_hook,$(gvdv))),
		$(eval $(call gen_volume_delete_nohook,$(gvdv))))
endef
# uniquePrefix: gvdh
define gen_volume_delete_hook
	$(eval gvdhv := $(strip $1))
	$(eval gvdhc := $(strip $($(gvdhv)_CONTROL)))
	$(if $(wildcard .touch_c_$(gvdhc)),
		$(eval $(call gen_volume_delete_hook_go,$(gvdhv))),
		$(eval $(call gen_volume_delete_hook_fail,$(gvdhv))))
endef
# uniquePrefix: gvdhg
define gen_volume_delete_hook_go
	$(eval gvdhgv := $(strip $1))
	$(eval gvdhgc := $(strip $($(gvdhgv)_CONTROL)))
	$(eval gvdhgz := $(strip $($(gvdhgv)_COMMAND)))
	$(eval $(call gen_volume_delete_nohook,$(gvdhgv)))
vol_$(gvdhgv)_delete: $(gvdhgc)_$(gvdhgz)
endef
# uniquePrefix: gvdnv
define gen_volume_delete_nohook
	$(eval gvdnv := $(strip $1))
vol_$(gvdnv)_delete:
	$Qecho "Deleting volume '$(gvdnv)'"
	$Qrm -rf vol_$(gvdnv)
endef
# uniquePrefix: gvdhf
define gen_volume_delete_hook_fail
	$(eval gvdhfv := $(strip $1))
	$(eval gvdhfc := $(strip $($(gvdhfv)_CONTROL)))
vol_$(gvdhfv)_delete:
	$Qecho "Deleting volume '$(gvdhfv)' requires container '$(gvdhfc)' for cleanup"
	$Qecho "(Consider 'make $(gvdhfc)_create'? I didn't want to force this on you.)"
	$Qexit 1
endef
# uniquePrefix: gvdnu
define gen_volume_delete_null
	$(eval gvdnuv := $(strip $1))
vol_$(gvdnuv)_delete:
endef
# Special note for vol_all_delete, coz this is weird. Normally, the dependency
# of vol_all_delete on vol_<everything>_delete is fine. Except in a weird
# situation, where the volume has stuff that needs specialized cleanup
# (<vol>_WILDCARD matches), and so it will run a command (<vol>_COMMAND) in a
# container (using image <vol>_CONTROL) to do that, but that container/command
# 2-tuple has a dependency on a bind-mount that _we may have already deleted_
# (because we're in vol_all_delete). In that case, the special work to
# eliminate one volume may recreate a volume we previously eliminated. (TODO:
# this probably means the vol_all_delete target isn't safe with parallel
# make??) Workaround: have vol_all_delete call itself a second time... erk.
# TODO: the fix is likely to be define an "_empty" generic for volumes, which
# the "_delete" generic(s) depend on.
define gen_volume_all_delete
vol_all_delete:
	$Q(if [ "v$(PASS2)" = "v" ]; then \
		PASS2=1 make vol_all_delete; \
	fi )
endef

# Put this rule at the end of the (ultimately assembled/generated) makefile,
# so that anything the user adds to MDIRS from their side of the makefile
# will get included in the rule
define gen_mdirs
$(MDIRS):
	$Qecho "Creating bind-mountable folder '$$@'"
	$Qmkdir -p $$@
endef

#############
# Recipe-time functions
#
# The preprocessing parses all inputs, builds up all the internal data, and
# generates rules and dependencies. That has the appearance and effect of
# dynamically generating "a makefile". Once that processing is done, we are in
# a situation that is equivalent to processing a static makefile, using
# whatever targets and parameters were passed to the "make" command (or the
# "default" target otherwise).
#
# The following functions don't participate in that preprocessing, but are
# called by the resulting rules, as various makefile targets get invoked "at
# recipe-time". Though there are $(eval) constructs here, the key point is that
# none of these are themselves called within an $(eval) construct. Therefore,
# the $(eval)s here force immedate expansion/evaluation as this code runs, but
# this code itself doesn't run _until recipe-time_.
#############

# Used by the "default:" rule to display a generic image command.
# uniquePrefix: lgi
define list_gen_img
	$(eval lgic := $(strip $1))
	$Qecho "  make <image>_$(lgic)  ($(gen_img_$(lgic)_DESCRIPTION))"
endef

# Used by the "default:" rule to display a container image and its commands.
# uniquePrefix: li
define list_img
	$(eval lii := $(strip $1))
	$Qecho "IMAGE: $(lii)  ($($(lii)_DESCRIPTION))"
	$(foreach c,$($(lii)_COMMANDS),$(call list_img_cmd,$(lii),$c))
endef
# uniquePrefix: lic
define list_img_cmd
	$(eval lici := $(strip $1))
	$(eval licc := $(strip $2))
	$Qecho "  make $(lici)_$(licc)  ($($(lici)_$(licc)_DESCRIPTION))"
endef

# Used by the "default:" rule to display a generic volume command.
# uniquePrefix: lgv
define list_gen_vol
	$(eval lgvc := $(strip $1))
	$Qecho "  make vol_<vol>_$(lgvc)  ($(gen_vol_$(lgvc)_DESCRIPTION))"
endef

# Used by the "default:" rule to display a volume.
# uniquePrefix: lv
define list_vol
	$(eval lv := $(strip $1))
	$Qecho "VOLUME: $(lv)  ($($(lv)_DESCRIPTION))"
endef

# The debug output logic. This runs at rule-time precisely so that it can
# display what the outcome was of all the other processing.
define dump_all
	$(foreach i,$(IMAGES),$(call dump_image,$i))
	$(foreach i,$(VOLUMES),$(call dump_volume,$i))
	$Qecho "MDIRS: $(MDIRS)"
endef
# uniquePrefix: di
define dump_image
	$(eval din := $(strip $1))
	$Qecho "IMAGE: $(din)"
	$Qecho "     path       : $($(din)_PATH)"
	$Qecho "     create_deps: $($(din)_create_deps)"
	$Qecho "     delete_deps: $($(din)_delete_deps)"
	$Qecho "     find_deps  : $($(din)_find_deps)"
	$Qecho "     from       : $($(din)_from)"
	$Qecho "     mountdeps  : $($(din)_mountdeps)"
	$Qecho "     mountargs  : $($(din)_mountargs)"
	$Qecho "     subcommands: $($(din)_subcommands)"
	$Qecho
endef
# uniquePrefix: di
define dump_volume
	$(eval div := $(strip $1))
	$Qecho "VOLUME: $(div)  (vol_$(div)_create)"
	$Qecho "     create_deps: $(vol_$(div)_create_deps)"
	$Qecho "     image_deps : $(vol_$(div)_image_deps)"
	$Qecho "     wildcard   : $($(div)_WILDCARD)"
	$Qecho "     control    : $($(div)_CONTROL)"
	$Qecho "     command    : $($(div)_COMMAND)"
	$Qecho
endef
