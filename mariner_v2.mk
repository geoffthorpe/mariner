#################
# Mariner setup #
#################

# The user's makefile has a couple of interaction with Mariner, and should
# generally follow this ordering;
#
# 1. include mariner_v2.mk
#     - this defines a variety of DEFAULT_* settings, but only if they haven't
#       already been defined by the user's makefile (or the environment).
#     - this defines the API functionality via numerous functions, but none
#       have been expanded/evaluated yet.
#
# 2. the user's makefile can alter variables that will govern Mariner behavior,
#    such as various "DEFAULT_" settings. Steps 1 and 2 can be reordered
#    arbitrarily. Though if the user wishes for Mariner defaults to be defined
#    before applying tweaks to them, they will want to perform step 1 first.
#
# 3. $(eval $(call do_mariner_prep))
#     - setting of global state occurs, as parameterized by defaults that are
#       coded in mariner_v2.mk (step 1) but that the user may have overriden
#       (step 2).
#     - this also fixes some run-time state, like creating a "crud" directory
#       for Mariner's autogenerated artifacts, optionally opening a TRACE file
#       in that crud directory, setting $Q (based on V, to control verbosity in
#       recipes), etc.
#
# 4. the user's makefile can set variables (IMAGES, VOLUMES, COMMANDS, ...),
#    and attributes that apply to them, to define their use-case. 
#
# 5. $(eval $(call do_mariner))
#     - the user's use-case gets processed
#     - the whole slew of autogenerated rules, dependencies, and recipes gets
#       produced to "Makefile.out" in the crud directory, and then sourced back
#       in by Mariner.
#     - if TRACE was enabled, Mariner debugging output is produced to a TRACE
#       file in the crud directory.
#
# Once all this is done, the make targets specified on the command-line are
# processed by GNU make.

$(eval TOPDIR ?= $(shell pwd))
$(eval DEFAULT_CRUD ?= $(TOPDIR)/crud)
#$(eval TRACE := 1)
$(eval MKOUT ?= $(DEFAULT_CRUD)/Makefile.out)
#$(eval V := 1)
$(eval MARINER_MK_PATH ?= $(TOPDIR)/mariner_v2.mk)
$(eval TOP_DEPS ?= mariner_v2.mk GNUmakefile)
$(eval DEFAULT_SHELL ?= /bin/sh)
$(eval DEFAULT_ARGS_FIND_DEPS ?= )
$(eval DEFAULT_ARGS_DOCKER_BUILD ?= --force-rm=true)
$(eval DEFAULT_ARGS_DOCKER_RUN ?= )
$(eval DEFAULT_RUNARGS_interactive ?= --rm -a stdin -a stdout -a stderr -i -t)
$(eval DEFAULT_RUNARGS_batch ?= --rm -i)
$(eval DEFAULT_RUNARGS_detach_nojoin ?= --rm -d)
$(eval DEFAULT_RUNARGS_detach_join ?= -d)
$(eval DEFAULT_COMMAND_PROFILES ?= interactive)
$(eval DEFAULT_NETWORK_MANAGED ?= true)
$(eval DEFAULT_VOLUME_OPTIONS ?= readwrite)
$(eval DEFAULT_VOLUME_MANAGED ?= true)
$(eval DEFAULT_VOLUME_SOURCE_MAP ?= mariner_default_volume_source_map)
$(eval DEFAULT_VOLUME_DEST_MAP ?= mariner_default_volume_dest_map)
$(eval DEFAULT_IMAGE_PATH_MAP ?= mariner_default_image_path_map)
$(eval DEFAULT_IMAGE_DNAME_MAP ?= mariner_default_image_dname_map)

# This is byref (=) not byval (:=), so it's actually defining an internal
# function for later expansion.
trace = $(file >>$(TRACEFILE),$(strip $1))

define do_mariner_prep
	$(if $(shell stat $(DEFAULT_CRUD) > /dev/null 2>&1 && echo YES),,
		$(shell mkdir $(DEFAULT_CRUD)))
	$(if $(strip $(TRACE)),
		$(if $(strip $(TRACEFILE)),,
			$(eval TRACEFILE := $(DEFAULT_CRUD)/TRACE)
			$(eval TRACEFILE := $(TRACEFILE)-$(shell date +%F-%H-%M-%S))
			$(eval TRACEFILE := $(TRACEFILE)-$(shell echo $$PPID)))
		$(file >$(TRACEFILE))
	,
		$(eval trace := ))
	$(eval $(call trace,start do_mariner_prep))
	$(eval $(call mkout_init))
	$(if $(strip $V),$(eval Q:=),$(eval Q:=@))
	$(eval $(call do_sanity_checks))
	$(eval $(call do_mariner_control))
	$(eval MARINER_PREP_RUN := 1)
	$(eval $(call trace,end do_mariner_prep))
endef

###########################
# Mariner main processing #
###########################

define do_mariner
	$(if $(MARINER_PREP_RUN),,$(error do_mariner_prep must be called before do_mariner))
	$(eval $(call trace,start do_mariner()))
	$(eval $(call process_networks))
	$(eval $(call process_volumes))
	$(eval $(call process_commands))
	$(eval $(call process_images))
	$(eval $(call process_2_image_command))
	$(eval $(call process_2_image_volume))
	$(eval $(call process_3_image_volume_command))
	$(eval $(call gen_rules_networks))
	$(eval $(call gen_rules_volumes))
	$(eval $(call gen_rules_images))
	$(eval $(call gen_rules_image_commands))
	$(eval $(call mkout_mdirs))
	$(eval $(call trace,end do_mariner()))
	$(eval $(call mkout_load))
endef

########################
# Default map routines #
########################

define mariner_default_volume_source_map
	$(eval $(call trace,start mariner_default_source_map($1)))
	$(eval $(strip $1)_SOURCE := $(TOPDIR)/vol_$(strip $1))
	$(eval $(call trace,set $(strip $1)_SOURCE := $(TOPDIR)/vol_$(strip $1)))
	$(eval $(call trace,end mariner_default_source_map($1)))
endef

define mariner_default_volume_dest_map
	$(eval $(call trace,start mariner_default_dest_map($1)))
	$(eval $(strip $1)_DEST := /$(strip $1))
	$(eval $(call trace,set $(strip $1)_DEST := $(TOPDIR)/vol_$(strip $1)))
	$(eval $(call trace,end mariner_default_dest_map($1)))
endef

define mariner_default_image_path_map
	$(eval $(strip $1)_PATH := $(TOPDIR)/c_$(strip $1))
endef

define mariner_default_image_dname_map
	$(eval $(strip $1)_DNAME := $(strip $1))
endef

####################
# Output functions #
####################

define mkout_comment
	$(file >>$(MKOUT),)
	$(file >>$(MKOUT),# $1)
endef

define mkout_header
	$(file >>$(MKOUT),)
	$(file >>$(MKOUT),########)
	$(file >>$(MKOUT),# $1)
	$(file >>$(MKOUT),########)
endef

define mkout_init
	$(eval $(call trace,start mkout_init))
	$(file >$(MKOUT),# Auto-generated makefile rules)
	$(file >>$(MKOUT),)
	$(eval $(call trace,end mkout_init))
endef

define mkout_load
	$(eval $(call trace,start mkout_load))
	include $(MKOUT)
	$(eval $(call trace,end mkout_load))
endef

# $1 is the target, $2 is the dependency, $3 is a list of variables, each of which
# represents a distinct line of the recipe (mkout_rule will indent these)
define mkout_rule
	$(eval $(call trace,start mkout_rule($1,$2,$3)))
	$(file >>$(MKOUT),)
	$(file >>$(MKOUT),$(strip $1): $(strip $2))
	$(foreach i,$(strip $3),
		$(eval $(call trace,-> $i=$($i)))
		$(file >>$(MKOUT),	$($i)))
	$(eval $(call trace,end mkout_rule($1,$2,$3)))
endef

# uniquePrefix: mlv
define mkout_long_var
	$(eval $(call trace,start mkout_long_var($1)))
	$(eval mlv := $(strip $1))
	$(file >>$(MKOUT),)
	$(file >>$(MKOUT),$(mlv) :=)
	$(foreach i,$($(mlv)),
		$(eval $(call trace,-> $i))
		$(file >>$(MKOUT),$(mlv) += $i))
	$(eval $(call trace,end mkout_long_var($1)))
endef

# The point of this routine (and the subsequent _else and _endif routines) are
# to put conditionals in the generated makefile, i.e. to avoid the condition
# being evaluated pre-expansion. (The conditional isn't there to decide on the
# makefile content that we're generating, it is supposed to be in the generated
# makefile content with the two possible outcomes, and be evaluate _there_,
# later on.) Be wary of escaping the relevant characters ("$", "#", etc) so
# they end up in the generated makefile content as intended.
# $1 is the shell command. Its stdout and stderr are redirected to /dev/null. The
#    conditional is considered TRUE if the command succeeded (zero exit code),
#    or FALSE if the command failed (non-zero exit code).
# uniquePrefix: mis
define mkout_if_shell
	$(eval $(call trace,start mkout_if_shell($1)))
	$(eval mis := $(strip $1))
	$(file >>$(MKOUT),)
	$(file >>$(MKOUT),isYES:=$$(shell $(mis) > /dev/null 2>&1 && echo YES))
	$(file >>$(MKOUT),ifeq (YES,$$(isYES)))
	$(eval $(call trace,end mkout_if_shell($1,$2,$3)))
endef
define mkout_else
	$(file >>$(MKOUT),)
	$(file >>$(MKOUT),else)
endef
define mkout_endif
	$(file >>$(MKOUT),)
	$(file >>$(MKOUT),endif)
endef

define mkout_mdirs
	$(eval $(call trace,start mkout_mdirs))
	$(eval $(call mkout_long_var,MDIRS))
	$(file >>$(MKOUT),)
	$(file >>$(MKOUT),$$(MDIRS):)
	$(file >>$(MKOUT),	$$Qecho "Creating empty directory '$$@'")
	$(file >>$(MKOUT),	$$Qmkdir -p $$@)
	$(eval $(call trace,end mkout_mdirs))
endef

#####################
# Utility functions #
#####################

# For the various verify_***() functions, $1 isn't the value to be checked, but
# the _name_ of the property that holds the value to be checked. This is
# "by-reference" to allow meaningful error messages.

# uniquePrefix: vnd
define verify_no_duplicates
	$(eval $(call trace,start verify_no_duplicates($1)))
	$(eval vndn := $(strip $1))
	$(eval vndi := $(strip $($(vndn))))
	$(eval vndo := )
	$(eval $(call trace,examining list; $(vndi)))
	$(foreach i,$(vndi),\
		$(if $(filter $i,$(vndo)),\
			$(error "Bad: duplicates in $(vndn)"),\
			$(eval vndo += $i)))
	$(eval $(call trace,end verify_no_duplicates($1)))
endef

# uniquePrefix: vloo
define verify_list_of_one
	$(eval $(call trace,start verify_list_of_one($1)))
	$(eval vloon := $(strip $1))
	$(eval vlooi := $(strip $($(vloon))))
	$(eval $(call trace,examining list; $(vlooi)))
	$(if $(filter 1,$(words $(vlooi))),,\
		$(error "Bad: $(vloon) list size != 1"))
	$(eval $(call trace,end verify_list_of_one($1)))
endef

# uniquePrefix: vil
define verify_in_list
	$(eval $(call trace,start verify_in_list($1,$2)))
	$(eval viln := $(strip $1))
	$(eval vili := $(strip $($(viln))))
	$(eval vilp := $(strip $2))
	$(eval vill := $(strip $($(vilp))))
	$(eval $(call trace,examining item; $(vili)))
	$(eval $(call trace,examining list; $(vill)))
	$(eval vilx := $(filter $(vill),$(vili)))
	$(eval vily := $(filter $(vili),$(vilx)))
	$(if $(vily),,$(error "Bad: $(viln) ($(vili)) is not in $(vilp)"))
	$(eval $(call trace,end verify_in_list($1,$2)))
endef

# uniquePrefix: vnil
define verify_not_in_list
	$(eval $(call trace,start verify_not_in_list($1,$2)))
	$(eval vniln := $(strip $1))
	$(eval vnili := $(strip $($(vniln))))
	$(eval vnilp := $(strip $2))
	$(eval vnill := $(strip $($(vnilp))))
	$(eval $(call trace,examining item; $(vnili)))
	$(eval $(call trace,examining list; $(vnill)))
	$(eval vnilx := $(filter $(vnill),$(vnili)))
	$(eval vnily := $(filter $(vnili),$(vnilx)))
	$(if $(vnily),$(error "Bad: $(vniln) ($(vnili)) is in $(vnilp)"))
	$(eval $(call trace,end verify_not_in_list($1,$2)))
endef

# uniquePrefix: vail
define verify_all_in_list
	$(eval $(call trace,start verify_all_in_list($1,$2)))
	$(eval vailn := $(strip $1))
	$(eval vaili := $(strip $($(vailn))))
	$(eval vailp := $(strip $2))
	$(eval vaill := $(strip $($(vailp))))
	$(foreach i,$(vaili),
		$(eval $(call trace,examining item; $(i)))
		$(eval $(call verify_in_list,i,$(vailp))))
	$(eval $(call trace,end verify_all_in_list($1,$2)))
endef

# uniquePrefix: vne
define verify_not_empty
	$(eval $(call trace,start verify_not_empty($1)))
	$(eval vnen := $(strip $1))
	$(eval vnei := $(strip $($(vnen))))
	$(eval $(call trace,examining value; $(vnei)))
	$(if $(vnei),,$(error "Bad: $(vnen) should be non-empty"))
	$(eval $(call trace,end verify_not_empty($1)))
endef

# uniquePrefix: vooo
define verify_one_or_other
	$(eval $(call trace,start verify_one_or_other($1,$2,$3)))
	$(eval vooon := $(strip $1))
	$(eval voooi := $(strip $($(vooon))))
	$(eval vooo1 := $(strip $2))
	$(eval vooo2 := $(strip $3))
	$(eval voooA := $(filter $(vooo1),$(voooi))) # Is it A?
	$(eval voooB := $(filter $(vooo2),$(voooi))) # Is it B?
	$(eval $(call trace,examining value; $(voooi)))
	$(if $(and $(voooA),$(voooB)),$(error "WTF? Bug?")) # Impossible
	$(if $(or $(voooA),$(voooB)),,\
		$(error "Bad: $(vooon) should be $(vooo1) or $(vooo2)"))
	$(eval $(call trace,end verify_one_or_other($1)))
endef

define verify_valid_BOOL
	$(eval $(call trace,start verify_valid_BOOL($1)))
	$(eval $(call verify_one_or_other,$1,true,false))
	$(eval $(call trace,end verify_valid_BOOL($1)))
endef
BOOL_is_true = $(filter true,$(strip $1))
BOOL_is_false = $(filter false,$(strip $1))

define verify_valid_OPTIONS
	$(eval $(call trace,start verify_valid_OPTIONS($1)))
	$(eval $(call verify_one_or_other,$1,readonly,readwrite))
	$(eval $(call trace,end verify_valid_OPTIONS($1)))
endef
OPTIONS_is_readonly = $(filter readonly,$(strip $1))
OPTIONS_is_readwrite = $(filter readwrite,$(strip $1))

# uniquePrefix: vvP
define verify_valid_PROFILE
	$(eval $(call trace,start verify_valid_PROFILE($1)))
	$(eval vvP := $(strip $1))
	$(if $(DEFAULT_RUNARGS_$(vvP)),,
		$(error "Bad: $(vvP) is not a valid command profile"))
	$(eval $(call trace,end verify_valid_PROFILE($1)))
endef

# uniquePrefix: vvPs
define verify_valid_PROFILES
	$(eval $(call trace,start verify_valid_PROFILES($1)))
	$(eval vvPs := $(strip $1))
	$(eval vvPsl := $($(vvPs)))
	$(eval $(call trace,examining list $(vvPsl)))
	$(foreach i,$(vvPsl),
		$(eval $(call verify_valid_PROFILE,$i)))
	$(eval $(call trace,end verify_valid_PROFILES($1)))
endef

# uniquePrefix: sie
define set_if_empty
	$(eval $(call trace,start set_if_empty($1,$2)))
	$(eval sien := $(strip $1))
	$(eval siei := $(strip $($(sien))))
	$(eval siea := $(strip $2))
	$(eval $(call trace,previous value of $(sien)=$(siei)))
	$(if $(siei),,$(eval $(sien) := $(siea)))
	$(eval siei := $(strip $($(sien))))
	$(eval $(call trace,new value of $(sien)=$(siei)))
	$(eval $(call trace,end set_if_empty($1,$2)))
endef

# uniquePrefix: mie
define map_if_empty
	$(eval $(call trace,start map_if_empty($1,$2,$3)))
	$(eval mien := $(strip $1))
	$(eval miei := $(strip $($(mien))))
	$(eval miea := $(strip $2))
	$(eval mieb := $(strip $3))
	$(eval $(call trace,previous value of $(mien)=$(miei)))
	$(if $(miei),,
		$(eval $(call trace,mapping $(mieb) -> $(miea)))
		$(eval $(call $(miea),$(mieb))))
	$(eval miei := $(strip $($(mien))))
	$(eval $(call trace,new value of $(mien)=$(miei)))
	$(eval $(call trace,end map_if_empty($1,$2,$3)))
endef

# uniquePrefix: ls
define list_subtract
	$(eval $(call trace,start list_subtract($1,$2)))
	$(eval lsX := $(strip $1))
	$(eval lsA := $(strip $($(lsX))))
	$(eval lsY := $(strip $2))
	$(eval lsB := $(strip $($(lsY))))
	$(eval $(call trace,current value of $(lsX)=$(lsA)))
	$(eval $(call trace,current value of $(lsY)=$(lsB)))
	$(eval $(lsX) := $(filter-out $(lsB),$(lsA)))
	$(eval $(call trace,new value of $(lsX)=$($(lsX))))
	$(eval $(call trace,end list_subtract($1,$2)))
endef

# This one is curious. $1 is the name of an IMAGE that _EXTENDS another. We
# grow the parent's _EXTENDED_BY property (which tracks "ancestors") with the
# name of the child and everything in the child's _EXTENDED_BY property,
# eliminating duplicates as we go (must be idempotent). In doing so, we always
# check that the parent doesn't find itself being one of its own ancestors -
# this is what detects circular deps.
#uniquePrefix: meb
define mark_extended_by
	$(eval $(call trace,start mark_extended_by($1)))
	$(eval mebX := $(strip $1))
	$(eval mebA := $(strip $($(mebX)_EXTENDED_BY)))
	$(eval mebY := $(strip $($(mebX)_EXTENDS)))
	$(eval mebB := $(strip $($(mebY)_EXTENDED_BY)))
	$(eval $(call trace,current value of $(mebX)_EXTENDED_BY=$(mebA)))
	$(eval $(call trace,current value of $(mebX)_EXTENDS=$(mebY)))
	$(eval $(call trace,current value of $(mebY)_EXTENDED_BY=$(mebB)))
	$(eval $(mebY)_EXTENDED_BY += $(mebX) $(mebA))
	$(eval $(call list_deduplicate,$(mebY)_EXTENDED_BY))
	$(eval $(call trace,new value of $(mebY)_EXTENDED_BY=$($(mebY)_EXTENDED_BY)))
	$(eval $(call trace,check for circular deps))
	$(eval $(call verify_not_in_list,$(mebX)_EXTENDS,$(mebY)_EXTENDED_BY))
	$(eval $(call trace,end mark_extended_by($1,$2)))
endef

# Given a volume source ($2), destination ($3), and options ($4), produce the
# required argument to "docker run" and append it to the given variable ($1).
# Note, we only support one OPTIONS, which is synthetically "readonly" or
# "readwrite". This needs to be converted to "readonly" or <empty>,
# respectively.
# uniquePrefix: mma
define make_mount_args
	$(eval $(call trace,start make_mount_args($1,$2,$3,$4)))
	$(eval mmav := $(strip $1))
	$(eval mmas := $(strip $2))
	$(eval mmad := $(strip $3))
	$(eval mmao := $(strip $4))
	$(eval mmar := --mount type=bind,source=$(mmas),destination=$(mmad))
	$(if $(call OPTIONS_is_readonly,$(mmao)),
		$(eval mmar := $(mmar),readonly))
	$(eval $(call trace,-> $(mmav) += $(mmar)))
	$(eval $(mmav) += $(mmar))
	$(eval $(call trace,end make_mount_args($1,$2,$3,$4)))
endef

#########################################
# Process NETWORKS and parse attributes #
#########################################

define process_networks
	$(eval $(call trace,start process_networks()))
	$(eval $(call verify_no_duplicates,NETWORKS))
	$(eval $(call trace,about to loop over NETWORKS=$(NETWORKS)))
	$(foreach i,$(NETWORKS),$(eval $(call process_network,$i)))
	$(eval $(call trace,end process_networks()))
endef

# uniquePrefix: tn
define trace_network
	$(eval $(call trace,start trace_network($1)))
	$(eval tn := $(strip $1))
	$(eval $(call trace,_DESCRIPTION=$($(tn)_DESCRIPTION)))
	$(eval $(call trace,_DNAME=$($(tn)_DNAME)))
	$(eval $(call trace,_MANAGED=$($(tn)_MANAGED)))
	$(eval $(call trace,_XTRA=$($(tn)_XTRA)))
	$(eval $(call trace,_TOUCHFILE=$($(tn)_TOUCHFILE)))
	$(eval $(call trace,end trace_network()))
endef

# uniquePrefix: pn
define process_network
	$(eval $(call trace,start process_network($1)))
	$(eval pn := $(strip $1))
	$(eval $(call trace_network, $(pn)))
	# If <net>_DNAME is empty, default to the Mariner object name
	$(eval $(call trace,examine _DNAME))
	$(eval $(call set_if_empty, \
		$(pn)_DNAME, \
		$(pn)))
	# If <net>_MANAGED is empty, inherit from the default
	$(eval $(call trace,examine _MANAGED))
	$(eval $(call set_if_empty, \
		$(pn)_MANAGED, \
		$(DEFAULT_NETWORK_MANAGED)))
	# If <net>_XTRA is empty, inherit from the default
	$(eval $(call trace,examine _XTRA))
	$(eval $(call set_if_empty, \
		$(pn)_XTRA, \
		$(DEFAULT_NETWORK_XTRA)))
	$(eval $(call trace,set internal defaults; TOUCHFILE))
	$(eval $(pn)_TOUCHFILE := $(DEFAULT_CRUD)/ntouch_$(pn))
	# Check the values are legit
	$(eval $(call trace,check attribs have legit values))
	$(eval $(call verify_valid_BOOL,$(pn)_MANAGED))
	$(eval $(call trace_network, $(pn)))
	$(eval $(call trace,end process_network()))
endef

########################################
# Process VOLUMES and parse attributes #
########################################

define process_volumes
	$(eval $(call trace,start process_volumes()))
	$(eval $(call verify_no_duplicates,VOLUMES))
	$(eval $(call trace,about to loop over VOLUMES=$(VOLUMES)))
	$(foreach i,$(VOLUMES),$(eval $(call process_volume,$i)))
	$(eval $(call trace,end process_volumes()))
endef

# uniquePrefix: tv
define trace_volume
	$(eval $(call trace,start trace_volume($1)))
	$(eval tvv := $(strip $1))
	$(eval $(call trace,_DESCRIPTION=$($(tvv)_DESCRIPTION)))
	$(eval $(call trace,_SOURCE=$($(tvv)_SOURCE)))
	$(eval $(call trace,_DEST=$($(tvv)_DEST)))
	$(eval $(call trace,_OPTIONS=$($(tvv)_OPTIONS)))
	$(eval $(call trace,_MANAGED=$($(tvv)_MANAGED)))
	$(eval $(call trace,_TOUCHFILE=$($(tvv)_TOUCHFILE)))
	$(eval $(call trace,end trace_volume()))
endef

# uniquePrefix: pv
define process_volume
	$(eval $(call trace,start process_volume($1)))
	$(eval pvv := $(strip $1))
	$(eval $(call trace_volume, $(pvv)))
	# If <vol>_SOURCE is empty, inherit from the default map
	$(eval $(call trace,examine _SOURCE))
	$(eval $(call map_if_empty, \
		$(pvv)_SOURCE, \
		$(DEFAULT_VOLUME_SOURCE_MAP), \
		$(pvv)))
	# If <vol>_DEST is empty, inherit from the default map
	$(eval $(call trace,examine _DEST))
	$(eval $(call map_if_empty, \
		$(pvv)_DEST, \
		$(DEFAULT_VOLUME_DEST_MAP), \
		$(pvv)))
	# If <vol>_OPTIONS is empty, inherit from the default
	$(eval $(call trace,examine _OPTIONS))
	$(eval $(call set_if_empty, \
		$(pvv)_OPTIONS, \
		$(DEFAULT_VOLUME_OPTIONS)))
	# If <vol>_MANAGED is empty, inherit from the default
	$(eval $(call trace,examine _MANAGED))
	$(eval $(call set_if_empty, \
		$(pvv)_MANAGED, \
		$(DEFAULT_VOLUME_MANAGED)))
	$(eval $(call trace,set internal defaults; TOUCHFILE))
	$(eval $(pvv)_TOUCHFILE := $(DEFAULT_CRUD)/vtouch_$(pvv))
	# Check the values are legit
	$(eval $(call trace,check attribs have legit values))
	$(eval $(call verify_valid_OPTIONS,$(pvv)_OPTIONS))
	$(eval $(call verify_valid_BOOL,$(pvv)_MANAGED))
	$(eval $(call verify_not_empty,$(pvv)_SOURCE))
	$(eval $(call verify_not_empty,$(pvv)_DEST))
	$(eval $(call trace_volume, $(pvv)))
	$(eval $(call trace,end process_volume()))
endef

#########################################
# Process COMMANDS and parse attributes #
#########################################

define process_commands
	$(eval $(call trace,start process_commands()))
	$(eval $(call verify_no_duplicates,COMMANDS))
	$(if $(filter $(COMMANDS),create),
		$(error "Bad: attempt to user-define 'create' COMMAND"))
	$(if $(filter $(COMMANDS),delete),
		$(error "Bad: attempt to user-define 'delete' COMMAND"))
	$(if $(filter-out $(COMMANDS),shell),
		$(eval $(call trace,adding _shell generic))
		$(eval COMMANDS += shell)
		$(eval $(call trace,-> COMMANDS=$(COMMANDS)))
		$(eval shell_COMMAND ?= $(DEFAULT_SHELL))
		$(eval shell_DESCRIPTION ?= start $(shell_COMMAND) in a container)
		$(eval shell_PROFILES ?= interactive))
	$(eval $(call trace,about to loop over COMMANDS=$(COMMANDS)))
	$(foreach i,$(strip $(COMMANDS)),
		$(eval $(call process_command,$i)))
	$(eval $(call trace,end process_commands()))
endef

# uniquePrefix: tc
define trace_command
	$(eval $(call trace,start trace_command($1)))
	$(eval tcv := $(strip $1))
	$(eval $(call trace,_DESCRIPTION=$($(tcv)_DESCRIPTION)))
	$(eval $(call trace,_COMMAND=$($(tcv)_COMMAND)))
	$(eval $(call trace,_DNAME=$($(tcv)_DNAME)))
	$(eval $(call trace,_PROFILES=$($(tcv)_PROFILES)))
	$(eval $(call trace,end trace_command()))
endef

# uniquePrefix: pc
define process_command
	$(eval $(call trace,start process_command($1)))
	$(eval pcv := $(strip $1))
	$(eval $(call trace_command, $(pcv)))
	# If _COMMAND is empty, explode
	$(eval $(call verify_not_empty, $(pcv)_COMMAND))
	# _PROFILES has a default, and needs validation
	$(eval $(call set_if_empty,$(pcv)_PROFILES,$(DEFAULT_COMMAND_PROFILES)))
	$(eval $(call verify_valid_PROFILES,$(pcv)_PROFILES))
	$(eval $(call trace_command,$(pcv)))
	$(eval $(call trace,end process_command()))
endef

#######################################
# Process IMAGES and parse attributes #
#######################################

define process_images
	$(eval $(call trace,start process_images()))
	$(eval $(call verify_no_duplicates,IMAGES))
	$(eval $(call trace,about to loop over IMAGES=$(IMAGES)))
	$(foreach i,$(IMAGES),$(eval $(call process_image,$i,)))
	$(eval $(call trace,end process_images()))
endef

# uniquePrefix: ti
define trace_image
	$(eval $(call trace,start trace_image($1)))
	$(eval tiv := $(strip $1))
	$(eval $(call trace,_DESCRIPTION=$($(tiv)_DESCRIPTION)))
	$(eval $(call trace,_TERMINATES=$($(tiv)_TERMINATES)))
	$(eval $(call trace,_EXTENDS=$($(tiv)_EXTENDS)))
	$(eval $(call trace,_PATH=$($(tiv)_PATH)))
	$(eval $(call trace,_NOPATH=$($(tiv)_NOPATH)))
	$(eval $(call trace,_DOCKERFILE=$($(tiv)_DOCKERFILE)))
	$(eval $(call trace,_PATH_FILTER=$($(tiv)_PATH_FILTER)))
	$(eval $(call trace,_HOSTNAME=$($(tiv)_HOSTNAME)))
	$(eval $(call trace,_DNAME=$($(tiv)_DNAME)))
	$(eval $(call trace,_PATH_MAP=$($(tiv)_PATH_MAP)))
	$(eval $(call trace,_DNAME_MAP=$($(tiv)_DNAME_MAP)))
	$(eval $(call trace,_NETWORKS=$($(tiv)_NETWORKS)))
	$(eval $(call trace,_UNNETWORKS=$($(tiv)_UNNETWORKS)))
	$(eval $(call trace,_VOLUMES=$($(tiv)_VOLUMES)))
	$(eval $(call trace,_UNVOLUMES=$($(tiv)_UNVOLUMES)))
	$(eval $(call trace,_COMMANDS=$($(tiv)_COMMANDS)))
	$(eval $(call trace,_UNCOMMANDS=$($(tiv)_UNCOMMANDS)))
	$(eval $(call trace,_ARGS_DOCKER_BUILD=$($(tiv)_ARGS_DOCKER_BUILD)))
	$(eval $(call trace,_ARGS_DOCKER_RUN=$($(tiv)_ARGS_DOCKER_RUN)))
	$(eval $(call trace,_DIN=$($(tiv)_DIN)))
	$(eval $(call trace,_DOUT=$($(tiv)_DOUT)))
	$(eval $(call trace,_TOUCHFILE=$($(tiv)_TOUCHFILE)))
	$(eval $(call trace,_FEATURES=$($(tiv)_FEATURES)))
	$(eval $(call trace,end trace_image($1)))
endef

# Note, this is an exception because it has to be reentrant. I.e. it calls
# itself, yet local variables are global, so how do we avoid self-clobber? The
# uniquePrefix stuff only makes local variables function-specific, but if the
# same function is present more than once in the same call-stack, we're toast.
# So the trick to deal with this is;
# - we use an initially-empty call parameter that gets appended to the
#   "uniquePrefix".
# - when calling ourselves, we append a character to that call parameter.
# - upon return from recursion, re-init the local uniquePrefix (to un-clobber
#   it).
# Also, just to be sexy, mark all images with a list of images that depend on
# it, call it _EXTENDED_BY. If an image is extended by itself, that indicates a
# circular dependency, so we can tell the user what the problem is rather than
# looping until we hit a process limit, an OOM-killer, or the heat-death of the
# universe.
# uniquePrefix: pi
define process_image
	$(eval $(call trace,start process_image($1,$2)))
	$(eval pip := pi$(strip $2))
	$(eval $(call trace,using uniqueness prefix $(pip)))
	$(eval $(pip)v := $(strip $1))
	$(eval $(call trace_image, $($(pip)v)))
	# Exactly one of <vol>_TERMINATES or <vol>_EXTENDS should be non-empty
	$(eval $(call trace,examine _TERMINATES and _EXTENDS))
	$(eval $($(pip)v)_tmp := $($($(pip)v)_TERMINATES) $($($(pip)v)_EXTENDS))
	$(eval $(call trace,set $($(pip)v)_tmp to _TERMINATES + _EXTENDS))
	$(eval $(call verify_list_of_one,$($(pip)v)_tmp))
	# Now, if _EXTENDS, we want to recurse into the image we depend on, so
	# it can sort out its attributes, rinse and repeat.
	$(if $($($(pip)v)_EXTENDS),
		$(eval $(call trace,verify $($(pip)v)_EXTENDS is known))
		$(eval $(call verify_in_list,$($(pip)v)_EXTENDS,IMAGES))
		$(eval $(call trace,grow _EXTENDED_BY, detect circular deps))
		$(eval $(call mark_extended_by,$($(pip)v)))
		$(eval $(call trace,recurse into $($(pip)v)_EXTENDS))
		$(eval $(call trace,pre-recurse; pip=$(pip)))
		$(eval $(call process_image,
			$($($(pip)v)_EXTENDS),
			$(strip $2)x))
		$(eval pip := pi$(strip $2))
		$(eval $(call trace,post-recurse; pip=$(pip)))
		$(eval $(call trace,examine _PATH_MAP (in _EXTENDS case)))
		$(eval $(call set_if_empty,
			$($(pip)v)_PATH_MAP,
			$($($($(pip)v)_EXTENDS)_PATH_MAP)))
		$(eval $(call trace,examine _DNAME_MAP (in _EXTENDS case)))
		$(eval $(call set_if_empty,
			$($(pip)v)_DNAME_MAP,
			$($($($(pip)v)_EXTENDS)_DNAME_MAP)))
		$(eval $(call trace,examine _NETWORKS (in _EXTENDS case)))
		$(eval $(call set_if_empty,
			$($(pip)v)_NETWORKS,
			$($($($(pip)v)_EXTENDS)_NETWORKS)))
		$(eval $(call trace,examine _VOLUMES (in _EXTENDS case)))
		$(eval $(call set_if_empty,
			$($(pip)v)_VOLUMES,
			$($($($(pip)v)_EXTENDS)_VOLUMES)))
		$(eval $(call trace,examine _COMMANDS (in _EXTENDS case)))
		$(eval $(call set_if_empty,
			$($(pip)v)_COMMANDS,
			$($($($(pip)v)_EXTENDS)_COMMANDS)))
		$(eval $(call trace,examine _ARGS_DOCKER_BUILD (in _EXTENDS case)))
		$(eval $(call set_if_empty,
			$($(pip)v)_ARGS_DOCKER_BUILD,
			$($($($(pip)v)_EXTENDS)_ARGS_DOCKER_BUILD)))
		$(eval $(call trace,examine _ARGS_DOCKER_RUN (in _EXTENDS case)))
		$(eval $(call set_if_empty,
			$($(pip)v)_ARGS_DOCKER_RUN,
			$($($($(pip)v)_EXTENDS)_ARGS_DOCKER_RUN)))
	,
		$(eval $(call trace,examine _PATH_MAP (in _TERMINATES case)))
		$(eval $(call set_if_empty,
			$($(pip)v)_PATH_MAP,
			$(DEFAULT_IMAGE_PATH_MAP)))
		$(eval $(call trace,examine _DNAME_MAP (in _TERMINATES case)))
		$(eval $(call set_if_empty,
			$($(pip)v)_DNAME_MAP,
			$(DEFAULT_IMAGE_DNAME_MAP)))
		$(eval $(call trace,examine _NETWORKS (in _TERMINATES case)))
		$(eval $(call set_if_empty,
			$($(pip)v)_NETWORKS,))
		$(eval $(call trace,examine _VOLUMES (in _TERMINATES case)))
		$(eval $(call set_if_empty,
			$($(pip)v)_VOLUMES,))
		$(eval $(call trace,examine _COMMANDS (in _TERMINATES case)))
		$(eval $(call set_if_empty,
			$($(pip)v)_COMMANDS,))
		$(if $(filter-out $($($(pip)v)_COMMANDS),shell),
			$(eval $(call trace,adding _shell generic (in _TERMINATES case)))
			$(eval $(call trace,before:$($(pip)v)_COMMANDS=$($($(pip)v)_COMMANDS)))
			$(eval $($(pip)v)_COMMANDS += shell)
			$(eval $(call trace, after:$($(pip)v)_COMMANDS=$($($(pip)v)_COMMANDS)))
			)
		$(eval $(call trace,examine _ARGS_DOCKER_BUILD (in _TERMINATES case)))
		$(eval $(call set_if_empty,
			$($(pip)v)_ARGS_DOCKER_BUILD,
			$(DEFAULT_ARGS_DOCKER_BUILD)))
		$(eval $(call trace,examine _ARGS_DOCKER_RUN (in _TERMINATES case)))
		$(eval $(call set_if_empty,
			$($(pip)v)_ARGS_DOCKER_RUN,
			$(DEFAULT_ARGS_DOCKER_RUN)))
		)
	$(eval $(call trace,examine _HOSTNAME))
	$(eval $(call set_if_empty,$($(pip)v)_HOSTNAME,$($(pip)v)))
	$(eval $(call trace,examine _PATH))
	$(eval $(call map_if_empty,
		$($(pip)v)_PATH,
		$($($(pip)v)_PATH_MAP),
		$($(pip)v)))
	$(eval $(call trace,examine _NOPATH))
	$(eval $(call set_if_empty,$($(pip)v)_NOPATH,false))
	$(eval $(call verify_valid_BOOL,$($(pip)v)_NOPATH))
	$(if $(call BOOL_is_true,$($($(pip)v)_NOPATH)),
		$(eval $($(pip)v)_PATH := false)
		$(if $(strip $($($(pip)v)_DOCKERFILE)),,
			$(error "Bad: $($(pip)v) set _NOPATH without setting _DOCKERFILE")))
	$(eval $(call trace,examine _DOCKERFILE))
	$(eval $(call set_if_empty,
		$($(pip)v)_DOCKERFILE,
		$($($(pip)v)_PATH)/Dockerfile))
	$(eval $(call trace,doing nothing with _PATH_FILTER))
	$(eval $(call trace,examine _DNAME))
	$(eval $(call map_if_empty,
		$($(pip)v)_DNAME,
		$($($(pip)v)_DNAME_MAP),
		$($(pip)v)))
	$(eval $(call trace,examine _UNNETWORKS))
	$(eval $(call list_subtract,
		$($(pip)v)_NETWORKS,
		$($(pip)v)_UNNETWORKS))
	$(eval $(call trace,examine _UNVOLUMES))
	$(eval $(call list_subtract,
		$($(pip)v)_VOLUMES,
		$($(pip)v)_UNVOLUMES))
	$(eval $(call trace,examine _UNCOMMANDS))
	$(eval $(call list_subtract,
		$($(pip)v)_COMMANDS,
		$($(pip)v)_UNCOMMANDS))
	$(eval $(call trace,set internal defaults; DOUT, DIN, TOUCHFILE))
	$(eval $($(pip)v)_DOUT := $(DEFAULT_CRUD)/Dockerfile_$($(pip)v))
	$(eval $($(pip)v)_DIN := $($($(pip)v)_DOCKERFILE))
	$(eval $($(pip)v)_TOUCHFILE := $(DEFAULT_CRUD)/touch_$($(pip)v))
	$(eval $(call trace,check _NETWORKS for legit values))
	$(eval $(call verify_all_in_list,$($(pip)v)_NETWORKS,NETWORKS))
	$(eval $(call trace,check _VOLUMES for legit values))
	$(eval $(call verify_all_in_list,$($(pip)v)_VOLUMES,VOLUMES))
	$(eval $(call trace,check _COMMANDS for legit values))
	$(eval $(call verify_all_in_list,$($(pip)v)_COMMANDS,COMMANDS))
	$(eval $(call trace_image, $($(pip)v)))
	$(eval $(call trace,end process_image($1,$2)))
endef

##########################################
# Parse IMAGE_COMMAND 2-tuple attributes #
##########################################

define process_2_image_command
	$(eval $(call trace,start process_2_image_command()))
	$(foreach i,$(IMAGES),$(foreach j,$($i_COMMANDS),
		$(eval $(call process_2ic,$i,$j))))
	$(eval $(call trace,end process_2_image_command()))
endef

# uniquePrefix: t2ic
define trace_2ic
	$(eval $(call trace,start trace_2ic($1)))
	$(eval t2ic := $(strip $1))
	$(eval $(call trace,_COMMAND=$($(t2ic)_COMMAND)))
	$(eval $(call trace,_HOSTNAME=$($(t2ic)_HOSTNAME)))
	$(eval $(call trace,_DNAME=$($(t2ic)_DNAME)))
	$(eval $(call trace,_NETWORKS=$($(t2ic)_NETWORKS)))
	$(eval $(call trace,_UNNETWORKS=$($(t2ic)_UNNETWORKS)))
	$(eval $(call trace,_VOLUMES=$($(t2ic)_VOLUMES)))
	$(eval $(call trace,_UNVOLUMES=$($(t2ic)_UNVOLUMES)))
	$(eval $(call trace,_PROFILES=$($(t2ic)_PROFILES)))
	$(eval $(call trace,_ARGS_DOCKER_RUN=$($(t2ic)_ARGS_DOCKER_RUN)))
	$(eval $(call trace,end trace_2ic($1)))
endef

# uniquePrefix: p2ic
define process_2ic
	$(eval $(call trace,start process_2ic($1,$2)))
	$(eval p2icI := $(strip $1))
	$(eval p2icC := $(strip $2))
	$(eval p2ic2 := $(p2icI)_$(p2icC))
	$(eval $(call trace_2ic, $(p2ic2)))
	$(eval $(call trace,examine _COMMAND))
	$(eval $(call set_if_empty,$(p2ic2)_COMMAND,$($(p2icC)_COMMAND)))
	$(eval $(call trace,examine _HOSTNAME))
	$(eval $(call set_if_empty,$(p2ic2)_HOSTNAME,$($(p2icI)_HOSTNAME)))
	$(eval $(call trace,examine _DNAME))
	$(eval $(call set_if_empty,$(p2ic2)_DNAME,$($(p2icC)_DNAME)))
	$(eval $(call trace,examine _NETWORKS))
	$(eval $(call set_if_empty,$(p2ic2)_NETWORKS,$($(p2icI)_NETWORKS)))
	$(eval $(call trace,examine _UNNETWORKS))
	$(eval $(call list_subtract,$(p2ic2)_VOLUMES,$(p2ic2)_UNVOLUMES))
	$(eval $(call trace,examine _VOLUMES))
	$(eval $(call set_if_empty,$(p2ic2)_VOLUMES,$($(p2icI)_VOLUMES)))
	$(eval $(call trace,examine _UNVOLUMES))
	$(eval $(call list_subtract,$(p2ic2)_VOLUMES,$(p2ic2)_UNVOLUMES))
	$(eval $(call trace,examine _PROFILES))
	$(eval $(call set_if_empty,$(p2ic2)_PROFILES,$($(p2icC)_PROFILES)))
	$(eval $(call verify_valid_PROFILES,$(p2ic2)_PROFILES))
	$(eval $(call trace,examine _ARGS_DOCKER_RUN))
	$(eval $(call set_if_empty,$(p2ic2)_ARGS_DOCKER_RUN,
		$($(p2icI)_ARGS_DOCKER_RUN) $($(p2icC)_ARGS_DOCKER_RUN)))
	$(eval $(call trace,set backrefs _IMAGE and _COMMAND))
	$(eval $(p2ic2)_B_IMAGE := $(p2icI))
	$(eval $(p2ic2)_B_COMMAND := $(p2icC))
	$(eval $(call trace_2ic, $(p2ic2)))
	$(eval $(call trace,end process_2ic($1,$2)))
endef

#########################################
# Parse IMAGE_VOLUME 2-tuple attributes #
#########################################

define process_2_image_volume
	$(eval $(call trace,start process_2_image_volume()))
	$(foreach i,$(IMAGES),$(foreach j,$($i_VOLUMES),
		$(eval $(call process_2iv,$i,$j))))
	$(eval $(call trace,end process_2_image_volume()))
endef

# uniquePrefix: t2iv
define trace_2iv
	$(eval $(call trace,start trace_2iv($1)))
	$(eval t2iv := $(strip $1))
	$(eval $(call trace,_DEST=$($(t2iv)_DEST)))
	$(eval $(call trace,_OPTIONS=$($(t2iv)_OPTIONS)))
	$(eval $(call trace,end trace_2iv($1)))
endef

# Note, the default handling (of the _DEST attribute) is dependent on whether
# the underlying image _EXTENDS another image. If it does, we have to recurse
# all the way in, in order for default-inheritence to always work backwards
# from the _TERMINATES layer back up the _EXTENDS chain. This means we need to
# play the same reentrancy trick we played in process_image.
# Fortunately we do not have to reproduce the buildup of _EXTENDED_BY
# attributes to handle loop detection, as those have already been
# detected/caught. Likewise, we don't need to do error detection (e.g. that
# $i_EXTENDS points to something legit in IMAGES) because that too has already
# happened.
# uniquePrefix: p2iv
define process_2iv
	$(eval $(call trace,start process_2iv($1,$2,$3)))
	$(eval p2iv := p2iv$(strip $3))
	$(eval $(call trace,using uniquess prefix $(p2iv)))
	$(eval $(p2iv)I := $(strip $1))
	$(eval $(p2iv)V := $(strip $2))
	$(eval $(p2iv)2 := $($(p2iv)I)_$($(p2iv)V))
	$(eval $(call trace_2iv, $($(p2iv)2)))
	# If _EXTENDS, recurse to the image-volume 2-tuple for the image that
	# is the immediate ancestor of this one. We go all the way to the
	# _TERMINATES case, and then do default-handling "on the way back" up
	# that dependency chain.
	$(if $($($(p2iv)I)_EXTENDS),
		$(eval $(call trace,recurse into $($($(p2iv)I)_EXTENDS)))
		$(eval $(call trace,pre-recurse; p2iv=$(p2iv)))
		$(eval $(call process_2iv,
			$($($(p2iv)I)_EXTENDS),
			$($(p2iv)V),
			$(strip $3)x))
		$(eval p2iv := p2iv$(strip $3))
		$(eval $(call trace,post-recurse; p2iv=$(p2iv)))
		$(eval $(call trace,examine _DEST))
		$(eval $(call set_if_empty,
			$($(p2iv)2)_DEST,
			$($($($(p2iv)I)_EXTENDS)_$($(p2iv)V)_DEST)))
		$(eval $(call trace,examine _OPTIONS))
		$(eval $(call set_if_empty,
			$($(p2iv)2)_OPTIONS,
			$($($($(p2iv)I)_EXTENDS)_$($(p2iv)V)_OPTIONS)))
	,
		$(eval $(call trace,examine _DEST))
		$(eval $(call set_if_empty,
			$($(p2iv)2)_DEST,
			$($($(p2iv)V)_DEST)))
		$(eval $(call trace,examine _OPTIONS))
		$(eval $(call set_if_empty,
			$($(p2iv)2)_OPTIONS,
			$($($(p2iv)V)_OPTIONS)))
		$(eval $(call verify_valid_OPTIONS,$($(p2iv)2)_OPTIONS))
	)
	$(eval $(call trace,set backrefs _IMAGE and _VOLUME))
	$(eval $($(p2iv)2)_B_IMAGE := $($(p2iv)I))
	$(eval $($(p2iv)2)_B_VOLUME := $($(p2iv)V))
	$(eval $(call trace_2iv, $($(p2iv)2)))
	$(eval $(call trace,end process_2iv($1,$2,$3)))
endef

###########################################
# IMAGE_VOLUME_COMMAND 3-tuple attributes #
###########################################

define process_3_image_volume_command
	$(eval $(call trace,start process_3_image_volume_command()))
	$(foreach i,$(IMAGES),
		$(foreach j,$($i_VOLUMES),
			$(foreach k,$($i_COMMANDS),
				$(eval $(call process_3ivc,$i,$j,$k)))))
	$(eval $(call trace,end process_3_image_volume_command()))
endef

# uniquePrefix: t3ivc
define trace_3ivc
	$(eval $(call trace,start trace_3ivc($1)))
	$(eval t3ivc := $(strip $1))
	$(eval $(call trace,_DEST=$($(t3ivc)_DEST)))
	$(eval $(call trace,_OPTIONS=$($(t3ivc)_OPTIONS)))
	$(eval $(call trace,end trace_3ivc($1)))
endef

# The processing here is quite analogous to the 2iv equivalent.
# uniquePrefix: p3ivc
define process_3ivc
	$(eval $(call trace,start process_3ivc($1,$2,$3,$4)))
	$(eval p3ivc := p3ivc$(strip $4))
	$(eval $(call trace,using uniquess prefix $(p3ivc)))
	$(eval $(p3ivc)I := $(strip $1))
	$(eval $(p3ivc)V := $(strip $2))
	$(eval $(p3ivc)C := $(strip $3))
	$(eval $(p3ivc)2 := $($(p3ivc)I)_$($(p3ivc)V))
	$(eval $(p3ivc)3 := $($(p3ivc)I)_$($(p3ivc)V)_$($(p3ivc)C))
	$(eval $(call trace_3ivc, $($(p3ivc)3)))
	# If _EXTENDS, recurse to the image-volume-command 3-tuple for the
	# image that is the immediate ancestor of this one. We go all the way
	# to the _TERMINATES case, and then do default-handling "on the way
	# back" up that dependency chain.
	$(if $($($(p3ivc)I)_EXTENDS),
		$(eval $(call trace,recurse into $($($(p3ivc)I)_EXTENDS)))
		$(eval $(call trace,pre-recurse; p3ivc=$(p3ivc)))
		$(eval $(call process_3ivc,
			$($($(p3ivc)I)_EXTENDS),
			$($(p3ivc)V),
			$($(p3ivc)C),
			$(strip $4)x))
		$(eval p3ivc := p3ivc$(strip $4))
		$(eval $(call trace,post-recurse; p3ivc=$(p3ivc)))
		$(eval $(call trace,examine _DEST))
		$(eval $(call set_if_empty,
			$($(p3ivc)3)_DEST,
			$($($($(p3ivc)I)_EXTENDS)_$($(p3ivc)V)_DEST)))
		$(eval $(call set_if_empty,
			$($(p3ivc)3)_DEST,
			$($($(p3ivc)2)_DEST)))
		$(eval $(call trace,examine _OPTIONS))
		$(eval $(call set_if_empty,
			$($(p3ivc)3)_OPTIONS,
			$($($($(p3ivc)I)_EXTENDS)_$($(p3ivc)V)_OPTIONS)))
	,
		$(eval $(call trace,examine _DEST))
		$(eval $(call set_if_empty,
			$($(p3ivc)3)_DEST,
			$($($(p3ivc)2)_DEST)))
		$(eval $(call trace,examine _OPTIONS))
		$(eval $(call set_if_empty,
			$($(p3ivc)3)_OPTIONS,
			$($($(p3ivc)2)_OPTIONS)))
		$(eval $(call verify_valid_OPTIONS,$($(p3ivc)3)_OPTIONS))
	)
	$(eval $(call trace,set backrefs _IMAGE, _VOLUME, and _COMMAND))
	$(eval $($(p3ivc)3)_B_IMAGE := $($(p3ivc)I))
	$(eval $($(p3ivc)3)_B_VOLUME := $($(p3ivc)V))
	$(eval $($(p3ivc)3)_B_COMMAND := $($(p3ivc)C))
	$(eval $(call trace_3ivc, $($(p3ivc)3)))
	$(eval $(call trace,end process_3ivc($1,$2,$3,$4)))
endef

##################################
# Generate 1-tuple NETWORK rules #
##################################

# Rules; create_NETWORKS, delete_NETWORKS
#
# Expand NETWORKS into the destination makefile (mkout_long_var), then use $(foreach)
# there too.
#
# create_NETWORKS :depends: on $(foreach NETWORKS)_create
#
# delete_NETWORKS :depends: on $(foreach NETWORKS)_delete
define gen_rules_networks
	$(eval $(call trace,start gen_rules_networks()))
	$(eval $(call verify_no_duplicates,NETWORKS))
	$(eval $(call mkout_header,NETWORKS))
	$(eval $(call mkout_comment,Aggregate rules for NETWORKS))
	$(eval $(call mkout_long_var,NETWORKS))
	$(eval MANAGED_NETWORKS := $(foreach i,$(NETWORKS),$(if $(call BOOL_is_true,$($i_MANAGED)),$i,)))
	$(eval $(call mkout_long_var,MANAGED_NETWORKS))
	$(eval $(call mkout_rule,create_NETWORKS,$$(foreach i,$$(MANAGED_NETWORKS),$$i_create)))
	$(eval $(call mkout_rule,delete_NETWORKS,$$(foreach i,$$(MANAGED_NETWORKS),$$i_delete)))
	$(eval $(call trace,about to loop over NETWORKS=$(NETWORKS)))
	$(foreach i,$(NETWORKS),$(eval $(call gen_rules_network,$i)))
	$(eval $(call trace,end gen_rules_networks()))
endef

# Rules; _create, _delete
#
# if :exists: .ntouch_$i
#   .ntouch_$i:
#   $i_delete:
#     -> :recipe: "echo Deleting network && rmdir" && rm .ntouch_$i
# else
#   .ntouch_$i: | $i_SOURCE
#     -> :recipe: "echo Created managed network" && touch .ntouch_$i
#   $i_delete:
#
# $i_create: :depends: on .ntouch_$i
#
# uniquePrefix: grn
define gen_rules_network
	$(eval $(call trace,start gen_rules_network($1)))
	$(eval grn := $(strip $1))
	$(if $(call BOOL_is_true,$($(grn)_MANAGED)),
		$(eval $(call trace,$(grn) is MANAGED))
		$(eval $(call mkout_comment,Rules for MANAGED network $(grn)))
		$(eval $(call mkout_if_shell,stat $($(grn)_TOUCHFILE)))
		$(eval $(call mkout_rule,$($(grn)_TOUCHFILE),,))
		$(eval grnx := $$Qecho "Deleting (managed) network $(grn)")
		$(eval grny := $$Qdocker network rm $($(grn)_DNAME))
		$(eval grnz := $$Qrm $($(grn)_TOUCHFILE))
		$(eval $(call mkout_rule,$(grn)_delete,,grnx grny grnz))
		$(eval $(call mkout_else))
		$(eval grnx := $$Qdocker network create $($(grn)_XTRA) $($(grn)_DNAME))
		$(eval grny := $$Qtouch $($(grn)_TOUCHFILE))
		$(eval grnz := $$Qecho "Created (managed) network $(grn)")
		$(eval $(call mkout_rule,$($(grn)_TOUCHFILE),,grnx grny grnz))
		$(eval $(call mkout_rule,$(grn)_delete,,))
		$(eval $(call mkout_endif))
		$(eval $(call mkout_rule,$(grn)_create,$($(grn)_TOUCHFILE),))
	,
		$(eval $(call trace,$(grn) is UNMANAGED))
		$(eval $(call mkout,comment,No rules for UNMANAGED network $(grn))))
	$(eval $(call trace,end gen_rules_network($1)))
endef

#################################
# Generate 1-tuple VOLUME rules #
#################################

# Rules; create_VOLUMES, delete_VOLUMES
#
# Expand VOLUMES into the destination makefile (mkout_long_var), then use $(foreach)
# there too.
#
# create_VOLUMES :depends: on $(foreach VOLUMES)_create
#
# delete_VOLUMES :depends: on $(foreach VOLUMES)_delete
define gen_rules_volumes
	$(eval $(call trace,start gen_rules_volumes()))
	$(eval $(call verify_no_duplicates,VOLUMES))
	$(eval $(call mkout_header,VOLUMES))
	$(eval $(call mkout_comment,Aggregate rules for VOLUMES))
	$(eval $(call mkout_long_var,VOLUMES))
	$(eval MANAGED_VOLUMES := $(foreach i,$(VOLUMES),$(if $(call BOOL_is_true,$($i_MANAGED)),$i,)))
	$(eval $(call mkout_long_var,MANAGED_VOLUMES))
	$(eval $(call mkout_rule,create_VOLUMES,$$(foreach i,$$(MANAGED_VOLUMES),$$i_create)))
	$(eval $(call mkout_rule,delete_VOLUMES,$$(foreach i,$$(MANAGED_VOLUMES),$$i_delete)))
	$(eval $(call trace,about to loop over VOLUMES=$(VOLUMES)))
	$(foreach i,$(VOLUMES),$(eval $(call gen_rules_volume,$i)))
	$(eval $(call trace,end gen_rules_volumes()))
endef

# Rules; _create, _delete
#
# if :exists: .vtouch_$i
#   .vtouch_$i:
#   $i_delete:
#     -> :recipe: "echo Deleting volume && rmdir" && rm .vtouch_$i
# else
#   .vtouch_$i: | $i_SOURCE
#     -> :recipe: "echo Created managed volume" && touch .vtouch_$i
#   $i_delete:
#
# $i_create: :depends: on .vtouch_$i
#
# uniquePrefix: grv
define gen_rules_volume
	$(eval $(call trace,start gen_rules_volume($1)))
	$(eval grv := $(strip $1))
	$(if $(call BOOL_is_true,$($(grv)_MANAGED)),
		$(eval $(call trace,$(grv) is MANAGED))
		$(eval $(call mkout_comment,Rules for MANAGED volume $(grv)))
		$(eval $(call mkout_if_shell,stat $($(grv)_TOUCHFILE)))
		$(eval $(call mkout_rule,$($(grv)_TOUCHFILE),,))
		$(eval grvx := $$Qecho "Deleting (managed) volume $(grv)")
		$(eval grvy := $$Qrmdir $($(grv)_SOURCE))
		$(eval grvz := $$Qrm $($(grv)_TOUCHFILE))
		$(eval $(call mkout_rule,$(grv)_delete,,grvx grvy grvz))
		$(eval $(call mkout_else))
		$(eval MDIRS += $($(grv)_SOURCE))
		$(eval grvx := $$Qtouch $($(grv)_TOUCHFILE))
		$(eval grvy := $$Qecho "Created (managed) volume $(grv)")
		$(eval $(call mkout_rule,$($(grv)_TOUCHFILE),| $($(grv)_SOURCE),grvx grvy))
		$(eval $(call mkout_rule,$(grv)_delete,,))
		$(eval $(call mkout_endif))
		$(eval $(call mkout_rule,$(grv)_create,$($(grv)_TOUCHFILE),))
	,
		$(eval $(call trace,$(grv) is UNMANAGED))
		$(eval $(call mkout,comment,No rules for UNMANAGED volume $(grv))))
	$(eval $(call trace,end gen_rules_volume($1)))
endef

################################
# Generate 1-tuple IMAGE rules #
################################

# Rules; create_IMAGES, delete_IMAGES
#
# Expand IMAGES into the destination makefile (mkout_long_var), then use $(foreach)
# there too.
#
# create_IMAGES :depends: on $(foreach IMAGES)_create
#
# delete_IMAGES :depends: on $(foreach IMAGES)_delete
define gen_rules_images
	$(eval $(call trace,start gen_rules_images()))
	$(eval $(call verify_no_duplicates,IMAGES))
	$(eval $(call mkout_header,IMAGES))
	$(eval $(call mkout_comment,Aggregate rules for IMAGES))
	$(eval $(call mkout_long_var,IMAGES))
	$(eval $(call mkout_rule,create_IMAGES,$$(foreach i,$$(IMAGES),$$i_create)))
	$(eval $(call mkout_rule,delete_IMAGES,$$(foreach i,$$(IMAGES),$$i_delete)))
	$(eval $(call trace,about to loop over IMAGES=$(IMAGES)))
	$(foreach i,$(IMAGES),$(eval $(call gen_rules_image,$i)))
	$(eval $(call trace,end gen_rules_images()))
endef

# Rules; _create, _delete
#
# .Dockerfile_$i .touch_$i :depends: on | $(DEFAULT_CRUD)
#
# .Dockerfile_$i :depends: on $(_DOCKERFILE)
#   -> :recipe: recreate .Dockerfile_$i
#
# if _EXTENDS
#   .touch_$i :depends: on .touch_$($i_EXTENDS)
#
# if _TERMINATES
#   .touch_$i :depends: on $(TOP_DEPS)
#
# .touch_$i :depends: on .Dockerfile_$i
#
# if ! _NOPATH
#   .touch_$i :depends: on "find _PATH"
#
# .touch_$i:
#   if _NOPATH
#     -> :recipe: "docker image rm && docker image prune" &&
#                 "cat _DOCKERFILE | docker build -" &&
#                 touch .touch_$i
#   else
#     -> :recipe: "docker image rm && docker image prune" &&
#                 "(cd _PATH && docker build .)" && 
#                 touch .touch_$i
#
# $i_create :depends: on .touch_$i
#
# if :exists: .touch_$i
#   if $i_EXTENDS
#       $($i_EXTENDS)_delete :depends: on $i_delete
#
#   $i_delete:
#     -> :recipe: "docker image rm && docker image prune" &&
#                  rm .Dockerfile_$i && rm .touch_$i
# else
#   $i_delete:
#
# A note about "docker build". Docker uses aggressive caching of intermediate
# images, such that if the daemon (constructing the image) is receiving a
# sequence of commands from the client (processing the Dockerfile) that are
# identical to ones that have been seen and processed in the past, it will
# reuse previous results rather than re-running those steps. Generally
# speaking, this is very efficient, especially for indiscriminate build/test
# scripts that otherwise replay often-identical constructions.
#
# However! Our inheritence scheme and our tracking of dependencies is not like
# some indiscriminate build script. If we trigger a makefile rule to (re)build
# an image, it is because "something changed". And here's the rub. The docker
# instructions being expanded from the Dockerfile may appear identical to
# docker, but many of the potential dependency triggers that lead to a rebuild
# attempt may have a material influence on what the results of those
# instructions will be. So we don't want Docker _assuming_ the contrary and
# using cached images instead. E.g. environment variables may have changed
# (from one of the files we declared a dependency on), or some file in the
# "context area" may have changed content (so identical instructions, from
# Docker's perspective, may be operating on different data and/or producing
# different results).
#
# uniquePrefix: gri
define gen_rules_image
	$(eval $(call trace,start gen_rules_image($1)))
	$(eval gri := $(strip $1))
	$(eval griUpdate1 := $$Qecho "Updating .Dockerfile_$(gri)")
	$(eval griUpdate2 := $$Qecho "FROM $(strip $($(gri)_EXTENDS) $($(gri)_TERMINATES))" > $($(gri)_DOUT))
	$(eval griUpdate3 := $$Qcat $($(gri)_DOCKERFILE) >> $($(gri)_DOUT))
	$(eval griRemove1 := $$Qecho "Deleting container image $(gri)")
	$(eval griRemove2 := $$Qdocker image rm $(gri) && docker image prune --force)
	$(eval griRemove3 := $$Qrm $($(gri)_TOUCHFILE))
	$(eval griBuild := docker build $($(gri)_ARGS_DOCKER_BUILD) -t $(gri))
	$(eval griCreate1 := $$Qecho "(re-)Creating container image $(gri)")
	$(if $(call BOOL_is_true,$($(gri)_NOPATH)),
		$(eval griCreate2 := $$Qcat $($(gri)_DOUT) | $(griBuild) - ),
		$(eval griCreate2 := $$Q(cd $($(gri)_PATH) && $(griBuild) -f $($(gri)_DOUT) . )))
	$(eval griCreate3 := $$Qtouch $($(gri)_TOUCHFILE))
	$(eval griUpdate := griUpdate1 griUpdate2 griUpdate3)
	$(eval griRemove := griRemove1 griRemove2 griRemove3)
	$(eval griCreate := griCreate1 griCreate2 griCreate3)
	$(eval $(call mkout_comment,Rules for IMAGE $(gri)))
	$(eval $(call mkout_rule,$($(gri)_DOUT) $($(gri)_TOUCHFILE),| $(DEFAULT_CRUD),))
	$(eval $(call mkout_rule,$($(gri)_DOUT),$($(gri)_DIN),$(griUpdate)))
	$(if $($(gri)_EXTENDS),
		$(eval $(call mkout_rule,$($(gri)_TOUCHFILE),$($($(gri)_EXTENDS)_TOUCHFILE),))
	,
		$(eval $(call mkout_rule,$($(gri)_TOUCHFILE),$(TOP_DEPS),))
	)
	$(eval $(call mkout_rule,$($(gri)_TOUCHFILE),$($(gri)_DOUT),))
	$(if $(call BOOL_is_false,$($(gri)_NOPATH)),
		$(eval $(call trace,set $(gri)_PATH_DEPS from $($(gri)_PATH)))
		$(eval $(gri)_PATH_DEPS := $(shell find $($(gri)_PATH) $($(gri)_PATH_FILTER)))
		$(eval $(call mkout_long_var,$(gri)_PATH_DEPS))
		$(eval $(call mkout_rule,$($(gri)_TOUCHFILE),$$($(gri)_PATH_DEPS),)))
	$(eval $(call mkout_rule,$(gri)_create,$($(gri)_TOUCHFILE),))
	$(eval $(call mkout_if_shell,stat $($(gri)_TOUCHFILE)))
		$(eval $(call mkout_rule,$($(gri)_TOUCHFILE),,$(griRemove) $(griCreate)))
		$(eval $(call mkout_rule,$(gri)_delete,,$(griRemove)))
		$(if $($(gri)_EXTENDS),
			$(call mkout_rule,$($(gri)_EXTENDS)_delete,$(gri)_delete,,))
	$(eval $(call mkout_else))
		$(eval $(call mkout_rule,$($(gri)_TOUCHFILE),,$(griCreate)))
		$(eval $(call mkout_rule,$(gri)_delete,,))
	$(eval $(call mkout_endif))
	$(eval $(call trace,end gen_rules_image($1)))
endef

########################################
# Generate 2-tuple IMAGE_COMMAND rules #
########################################

define gen_rules_image_commands
	$(eval $(call trace,start gen_rules_image_commands()))
	$(eval $(call mkout_header,IMAGE_COMMAND 2-tuples))
	$(foreach i,$(IMAGES),
		$(eval $(call trace,i=$i))
		$(eval $(call trace,i_COMMANDS=$($i_COMMANDS)))
		$(foreach j,$($i_COMMANDS),
			$(eval $(call gen_rules_image_command,$i,$j))))
	$(eval $(call trace,end gen_rules_image_commands()))
endef


# Rules; $1_$2 (<image>_<command>), $1_$2_$(foreach $($1_$2_PROFILES))
# Note, the 1-tuple rule-generation for images and volumes was only dependent
# on the corresponding 1-tuple processing. Things are different here. One
# 2-tuple (image/command) processing has occurred, 3-tuple image/command/volume
# processing occurs which pulls in and consolidates
# defaults/inheritence/overrides info from the 1-tuple and 2-tuple processing.
# So many of the inputs to these rules come from 3-tuple processing that
# potentially overrides the 2-tuple processing results. These are the inputs
# and which tuples they come from;
#  3ivc: DEST, OPTIONS
#   2ic: COMMAND, DNAME, VOLUMES
#    1i: HOSTNAME, PATH, NETWORKS
#    1v: SOURCE
# Once all that is considered, we actually have to generate a rule for each
# PROFILE that's supported, and then define the generic (PROFILE-agnostic) rule
# to be an alias for the first listed PROFILE.
#
# Special handling for the "detach_join" profile;
# - use a different gen function to produce rules, as we have distinct "launch"
#   and "wait" rules to create. (No need to do this for "detach_nojoin", which
#   is a fire-and-forget semantic.)
# - if $(command)_detach_join_HIDE is set (non-empty), generate the launch/wait
#   rules in terms of the underlying touchfiles but do _not_ generate the
#   visible "_launch" and "_wait" dependency targets. See the comments for the
#   gen_rule_image_command_profile_join function below.
#
# uniquePrefix: gric
define gen_rules_image_command
	$(eval $(call trace,start gen_rules_image_command($1,$2)))
	$(eval grici := $(strip $1))
	$(eval gricc := $(strip $2))
	$(eval gricic := $(grici)_$(gricc))
	$(eval $(call mkout_comment,Rules for IMAGE/COMMAND $(gricic)))
	$(eval $(call trace,generating $(gricic) deps))
	$(eval $(gricic)_DEPS := $($(grici)_TOUCHFILE))
	$(eval $(gricic)_DEPS += $(foreach i,$($(gricic)_NETWORKS),$(strip
		$(if $(call BOOL_is_true,$($i_MANAGED)),$($i_TOUCHFILE),))))
	$(eval $(gricic)_DEPS += $(foreach i,$($(gricic)_VOLUMES),$(strip
		$(if $(call BOOL_is_true,$($i_MANAGED)),$($i_TOUCHFILE),))))
	$(eval $(call mkout_long_var,$(gricic)_DEPS))
	$(eval $(gricic)_MOUNT_ARGS := )
	$(foreach i,$($(grici)_NETWORKS),
		$(eval $(gricic)_NETWORK_ARGS += --network $($i_DNAME) $($i_XTRA)))
	$(eval $(call mkout_long_var,$(gricic)_NETWORK_ARGS))
	$(foreach i,$($(gricic)_VOLUMES),
		$(eval $(gricic)_MOUNT_ARGS +=
			$(eval $(call make_mount_args,
				$(gricic)_MOUNT_ARGS,
				$($i_SOURCE),
				$($(grici)_$i_$(gricc)_DEST),
				$($(grici)_$i_$(gricc)_OPTIONS)))))
	$(eval $(call mkout_long_var,$(gricic)_MOUNT_ARGS))
	$(foreach i,$($(gricic)_PROFILES),
		$(if $(filter detach_join,$i),
			$(eval h := $(strip $($(gricc)_detach_join_HIDE)))
			$(eval $(call gen_rule_image_command_profile_join,$(gricic),$i,$h))
		,
			$(eval $(call gen_rule_image_command_profile,$(gricic),$i))
		))
	$(eval $(call mkout_rule,$(gricic),
		$(gricic)_$(firstword $($(gricic)_PROFILES))))
	$(eval $(call trace,end gen_rules_image_command($1,$2)))
endef

# uniquePrefix: gricp
define gen_rule_image_command_profile
	$(eval $(call trace,end gen_rule_image_command_profile($1,$2)))
	$(eval gricp2 := $(strip $1))
	$(eval gricpP := $(strip $2))
	$(eval gricpC := $(strip $($(gricp2)_COMMAND)))
	$(eval gricpA := $(strip $($(gricp2)_ARGS_DOCKER_RUN)))
	$(eval gricpBI := $(strip $($(gricp2)_B_IMAGE)))
	$(eval gricpBC := $(strip $($(gricp2)_B_COMMAND)))
	$(if $($(gricic)_DNAME),
		$(eval TMP1 := \
$$Qecho "Launching $(gricpP) container '$($(gricp2)_DNAME)'"),
		$(eval TMP1 := \
$$Qecho "Launching a '$(gricpBI)' $(gricpP) container running command ('$(gricpBC)')"))
	$(eval TMP2 := $$Qdocker run $(DEFAULT_RUNARGS_$(gricpP)) \)
	$(eval TMP3 := $(gricpA) --hostname $($(gricp2)_HOSTNAME) \)
	$(eval TMP4 := $$$$($(gricp2)_NETWORK_ARGS) \)
	$(eval TMP5 := $$$$($(gricp2)_MOUNT_ARGS) \)
	$(eval TMP6 := $(gricpBI) \)
	$(eval TMP7 := $(gricpC))
	$(eval $(call mkout_rule,$(gricp2)_$(gricpP),$$($(gricp2)_DEPS),
		TMP1 TMP2 TMP3 TMP4 TMP5 TMP6 TMP7))
	$(eval $(call trace,end gen_rule_image_command_profile($1,$2)))
endef

# This implements a tick-tock trick using two touchfiles, a "joinfile" and a
# "donefile", which respectively represent the two states of "async command has
# been launched and we haven't yet ensured its completion and cleaned up after
# it" and "we're idle/quiescent and could launch a new async command". So in
# the default/quiescent state, there is no touchfile at all or there is a
# left-over "donefile" from a previous, completed command. In the
# launched-but-not-yet-reaped state, there is a "joinfile" and no "donefile".
#
# Launching of the async command is triggered by dependency on the "joinfile",
# which itself is dependent on upstream (build) dependencies (if anything is
# out-of-date, rebuild it before pursuing any of our async command stuff). When
# the joinfile is absent (quiescence), the dependency triggers the launching of
# a command, which writes its container-ID to the "joinfile" (thus creating
# it). At this point, further dependence on the "joinfile" will give "nothing
# left to do", which is the metaphor we want for "dependence on launching the
# command is met, because the command has been launched".
#
# Dependence on the command being completed is produced by a dependency on the
# "donefile", which is itself dependent on the "joinfile", and if triggered
# causes us to;
# - re-attach to the container and wait for its exit (which may have already
#   happened),
# - remove the "joinfile", and
# - create the "donefile".
# This puts us back in the quiescent state. Rinse and repeat.
#
# A curious implication; dependence on the donefile causes us to wait for
# completion of (and clean up after) the launched command _if it had been
# launched_, otherwise it first causes the launching of the command (by its
# dependence on the joinfile) and _then_ blocks on its completion. I.e.;
# - For async semantics;
#   - depend on the joinfile to launch, and
#   - depend on the donefile to block on completion.
# - For blocking semantics;
#   - depend on the donefile directly!
#
# Another trick. First, note that by default we create named targets,
# $(image)_$(command)_launch and $(image)_$(command)_wait, that depend on the
# joinfile and donefile respectively. (By having the files use absolute paths,
# starting with "/", they don't pollute the space of visible targets to bash's
# tab-completion. Having the named targets gives visible wrappers for the
# launch/wait behavior.) However, if parameter $3 is non-empty, we use that as
# a trigger to _not_ generate the visible wrapper targets. Why? Well, if you
# build a test-case that will launch a lot of commands in one part of the
# workflow (by dependence on all the respective joinfiles) and then wait for
# them to all complete in another part of the workflow (by dependence on the
# respective donefiles), you are presumably going to wrap that cumulative
# "launch"/"wait" behavior into a single pair of targets (with its own
# joinfile/donefile depending on all the underlying ones). Having the multiple
# inner async commands _not_ generate visible wrapper targets is a UX advantage
# here.
#
# uniquePrefix: gricpj
define gen_rule_image_command_profile_join
	$(eval $(call trace,end gen_rule_image_command_profile_join($1,$2)))
	$(eval gricpj2 := $(strip $1))
	$(eval gricpjP := $(strip $2))
	$(eval gricpj_hide_wrappers := $(strip $3))
	$(eval gricpj_joinfile := $(DEFAULT_CRUD)/jjoinfile_$(gricpj2))
	$(eval gricpj_donefile := $(DEFAULT_CRUD)/jdonefile_$(gricpj2))
	$(eval gricpjC := $(strip $($(gricpj2)_COMMAND)))
	$(eval gricpjA := $(strip $($(gricpj2)_ARGS_DOCKER_RUN)))
	$(eval gricpjBI := $(strip $($(gricpj2)_B_IMAGE)))
	$(eval gricpjBC := $(strip $($(gricpj2)_B_COMMAND)))
	$(if $($(gricic)_DNAME),
		$(eval TMP1 := \
$$Qecho "Launching $(gricpjP) container '$($(gricpj2)_DNAME)'"),
		$(eval TMP1 := \
$$Qecho "Launching a '$(gricpjBI)' $(gricpjP) container running command ('$(gricpjBC)')"))
	$(eval TMP2 := $$Qdocker run $(DEFAULT_RUNARGS_$(gricpjP)) \)
	$(eval TMP3 := $(gricpA) --hostname $($(gricp2)_HOSTNAME) \)
	$(eval TMP4 := $$$$($(gricpj2)_NETWORK_ARGS) \)
	$(eval TMP5 := $$$$($(gricpj2)_MOUNT_ARGS) \)
	$(eval TMP6 := --cidfile=$(gricpj_joinfile) \)
	$(eval TMP7 := $(gricpjBI) \)
	$(eval TMP8 := $(gricpjC))
	$(eval $(call mkout_rule,$(gricpj_joinfile),$$($(gricpj2)_DEPS),
		TMP1 TMP2 TMP3 TMP4 TMP5 TMP6 TMP7 TMP8))
	$(eval TMP1 := \
$$Qecho "Waiting on completion of container '$(gricpj2)_$(gricpjP)'")
	$(eval TMP2 := $$Qcid=`cat $(gricpj_joinfile)` && \)
	$(eval TMP3 := rcode=`docker container wait $$$$$$$$cid` && \)
	$(eval TMP4 := (docker container rm $$$$$$$$cid > /dev/null 2>&1) && \)
	$(eval TMP5 := (exit $$$$$$$$rcode))
	$(eval TMP6 := $$Qrm $(gricpj_joinfile))
	$(eval TMP7 := $$Qtouch $(gricpj_donefile))
	$(eval $(call mkout_rule,$(gricpj_donefile),$(gricpj_joinfile),
		TMP1 TMP2 TMP3 TMP4 TMP5 TMP6 TMP7))
	$(if $(gricpj_hide_wrappers),,
		$(eval $(call mkout_rule,$(gricpj2)_$(gricpjP)_launch,$(gricpj_joinfile),))
		$(eval $(call mkout_rule,$(gricpj2)_$(gricpjP)_wait,$(gricpj_donefile),))
		$(eval $(call mkout_rule,$(gricpj2)_$(gricpjP),$(gricpj2)_$(gricpjP)_wait,)))
	$(eval $(call trace,end gen_rule_image_command_profile_join($1,$2)))
endef

#################
# SANITY CHECKS #
#################

# I learned a lot about weird GNU make behavior in constructing this function.
# Long story short, the final sed in the pipeline is necessary to avoid having
# any output duplicate "uniquePrefix" lines from getting re-expanded. In
# particular, matching lines all begin with a "#", and without the sed
# component they "disappear".
define do_sanity_checks
	$(eval $(call trace,start do_sanity_checks))
	$(eval UID_CONFLICTS := \
		$(shell egrep "^# uniquePrefix:" $(MARINER_MK_PATH) | sort |
			uniq -d | sed 's/[\\\#]/\\&/g'))
	$(if $(strip $(UID_CONFLICTS)),
		$(info $(UID_CONFLICTS)) $(error Conflicting uniquePrefix))
	$(if $(shell dpkg --compare-versions 4.2 \<= $(MAKE_VERSION) > /dev/null 2>&1 && echo YES),,\
		$(error "Bad: GNU make 4.2 or later is required"))\
	$(eval $(call trace,end do_sanity_checks))
endef

##############
# TERMINATOR #
##############

# This "control-file" processing gets called early, during do_mariner_prep, in
# order to intercept any environment variables that are intended to alter
# "control" settings.  These are especially important for "terminator"
# adaptations (proxies, CA certs, ...)
#
# There are multiple control files that can be setup/manipulated(/used)
# independently, they're listed in $(mariner_control). (For shell/escaping
# reasons, we cannot use hyphens in environment variable names, so stick with
# underscores. However the variables can have _values_ with have hyphens in
# them.) To edit any control file at all, the MARINER_CONTROL environment
# variable must be set. Therefore, unsetting that is a good way to prevent
# further change, even if other environment variables are left defined. Then,
# to manipulate a specific control-file, e.g. "web_proxy", the SET_web_proxy
# environment variable must also be set. If both of those are true, then the
# settings that belong to the that control-file will be read from the
# environment, and if any of them have been changed, the "control-web_proxy.mk"
# file (in the crud directory) will be updated.
#
# The settings belonging to each control file are listed in the corresponding
# $(<name>_args) variable. E.g.  web_proxy_args contains http_proxy,
# https_proxy, [...], so those proxy settings belong to the web_proxy
# control-file, and can be updated by setting their environment variables as
# well as MARINER_CONTROL and SET_web_proxy.

mariner_control := \
	web_proxy \
	trust_roots \
	docker
mariner_control_files := $(foreach i,$(mariner_control),$(DEFAULT_CRUD)/control-$i)

# Setting "SET_web_proxy" allows "{all,http,https,ftp,no}_proxy" environment
# variables to be baked into "docker build" and "docker run" commands for the
# corresponding image(s). If the container environment needs to rewrite
# anything in those environment variables, they are run through $(subst) using
# the "match_from" and "match_to" variables, if they are both set.
web_proxy_args := \
	$(foreach i,all http https ftp no,$i_proxy) \
	match_from \
	match_to

# Setting "SET_trust_roots" allows CA certificates to be embedded into the
# corresponding container image(s), if the ca_path env-var is set. NB: this
# results in some debian-specific boilerplate being injected into a Dockerfile,
# so YMMV trying to use this unmodified for other system types. ca_path is
# assumed to point to a directory containing certs. By default, the certs to
# use are determined by;
#     cd $(ca_path) && find -L . -type f -name "*.crt" | sed -e s/^\.\//
# But if ca_match is defined, it will be used as the match rule instead;
#     cd $(ca_path) && find -L . $(ca_filter) | sed -e s/^\.\//
trust_roots_args := \
	ca_path \
	ca_filter

# Setting "SET_docker" allows a "docker_prefix" environment variable to specify
# a prefix to be preprended to the external docker image's name[:tag].
# E.g. if
#     docker_prefix := dockerhub.internal.foo.com/mirror/
# then specifying "debian:latest" as the external image will get replaced with;
#     FROM dockerhub.internal.foo.com/mirror/debian:latest
# in the resulting Dockerfile.
# Note the trailing "/" in the above example of docker_prefix! The Mariner
# logic does not assume that a "/" separator is desired, because a user has the
# option of prepending not just a host and a path, but also prefixing the image
# name itself. For most cases though, a trailing "/" would be expected.
docker_args := \
	docker_prefix

# uniquePrefix: cf
define control_file
	$(eval $(call trace,start control_file($1)))
	$(eval cf := $(strip $1))
	$(eval cfT := $(DEFAULT_CRUD)/tmp-control-$(cf))
	$(eval cfF := $(DEFAULT_CRUD)/control-$(cf))
	$(eval cfA := $(strip $($1_args)))
	$(if $(and $(MARINER_CONTROL),$(SET_$(cf))),
		$(eval $(call trace,contemplating control file $(cf)))
		$(file >$(cfT),# Auto-generated control file)
		$(foreach i,$(cfA),
			$(eval x := $(strip $($i)))
			$(if $x,
				$(file >>$(cfT),$$(eval $i := $x)),
				$(file >>$(cfT),undefine $i)))
		$(if $(shell cmp $(cfT) $(cfF) > /dev/null 2>&1 && echo YES),
			$(eval $(call trace,control file $(cfF) unchanged))
			$(shell rm -f $(cfT))
		,
			$(eval $(call trace,control file $(cfF) changed))
			$(shell mv -f $(cfT) $(cfF))
		)
	,
		$(eval $(call trace,skipping control file $(cf)))
		$(if $(shell stat $(cfF) > /dev/null 2>&1 && echo YES),,
			$(eval $(call trace,but putting an empty place-holder there))
			$(file >$(cfF),# Auto-generated control file))
	)
	$(eval $(call trace,end control_file($1)))
endef

# uniquePrefix: dmc
define do_mariner_control
	$(eval $(call trace,start do_mariner_control))
	$(foreach i,$(mariner_control),
		$(eval dmc := $(strip $i))
		$(eval dmcF := $(DEFAULT_CRUD)/control-$(dmc))
		$(eval $(call control_file,$(dmc)))
		$(eval $(call trace,loading control file $(dmcF)))
		$(file <$(dmcF)))
	$(eval $(call trace,end do_mariner_control))
endef

# Special "terminator" handling creates a new IMAGE, located in the crud
# directory, that can have special bootstrapping baked into it. That special
# bootstrapping is governed by the "control file" stuff explained above. This
# provides a way of coding up a hierarchy of Mariner objects that build and run
# in "normal" environments, and then having them all work in "abnormal"
# environments without forking or wrapping everything in adaptation layers.
# (The adaptations are inserted at the lowest layer, on top of the external
# images.)

# uniquePrefix: mmt
define make_mariner_terminator
	$(eval $(call trace,start make_mariner_terminator($1,$2)))
	$(eval mmtName := $(strip $1))
	$(eval mmtPath := $(DEFAULT_CRUD)/terminator-$(mmtName))
	$(eval mmtPathCA := $(mmtPath)/CA-certs)
	$(eval mmtImgCA := /usr/share/ca-certificates/Mariner-injection/)
	$(eval mmtEtcCA := /etc/ca-certificates.conf)
	$(eval mmtExt := $(strip $2))
	$(eval mmtCAp := $(strip $(ca_path)))
	$(eval mmtCAm := $(strip $(ca_filter)))
	$(eval mmtCAt := $(DEFAULT_CRUD)/CA-$(mmtName))

	$(eval $(call trace,verifying that $(mmtPath) exists))
	$(if $(shell stat $(mmtPath) > /dev/null 2>&1 && echo YES),,
		$(eval $(call trace,nope, try to create it))
		$(shell mkdir $(mmtPath)))

	$(eval $(call trace,setting basic properties for $(mmtName)))
	$(eval $(mmtName)_DESCRIPTION := Auto-generated terminator image)
	$(eval $(mmtName)_PATH := $(mmtPath))
	$(eval $(mmtName)_DOCKERFILE := $(mmtPath)/Dockerfile)
	$(eval $(mmtName)_TERMINATES := $(mmtExt))
	$(eval $(mmtName)_PATH_FILTER := -path "*/CA-certs" -prune -o -print)

	$(eval $(call trace,processing web_proxy::{all|http|https|ftp|no}_proxy))
	$(eval $(mmtName)_ARGS_DOCKER_BUILD := $(DEFAULT_ARGS_DOCKER_BUILD))
	$(eval $(mmtName)_ARGS_DOCKER_RUN := $(DEFAULT_ARGS_DOCKER_RUN))
	$(foreach i,$(foreach j,all http https ftp no,$j_proxy),$(if $($i),
		$(eval $(call trace,value specified; $i=$($i)))
		$(if $(and $(match_from),$(match_to)),
			$(eval $(call trace,substituting from=$(match_from) and to=$(match_to)))
			$(eval v := $(strip $(subst $(match_from),$(match_to),
					$($i))))
			$(eval $(call trace,resulting; $i=$v))
		,
			$(eval v := $(strip $($i)))
		)
		$(eval $(mmtName)_ARGS_DOCKER_BUILD += --build-arg=$i="$v")
		$(eval $(mmtName)_ARGS_DOCKER_RUN += --env=$i="$v")
		$(eval $(call trace,-> $(mmtName)_ARGS_DOCKER_BUILD=$($(mmtName)_ARGS_DOCKER_BUILD)))
		$(eval $(call trace,-> $(mmtName)_ARGS_DOCKER_RUN=$($(mmtName)_ARGS_DOCKER_RUN)))))

	$(eval $(call trace,processing trust_roots::ca_{path|filter}))
	$(if $(mmtCAp),
		$(eval $(call trace,verifying that $(mmtPathCA) exists))
		$(if $(shell stat $(mmtPathCA) > /dev/null 2>&1 && echo YES),,
			$(eval $(call trace,nope, try to create it))
			$(shell mkdir $(mmtPathCA)))
	,
		$(eval $(call trace,verifying that $(mmtPathCA) does not exist))
		$(if $(shell stat $(mmtPathCA) > /dev/null 2>&1 && echo YES),
			$(eval $(call trace,nope, try to remove it))
			$(shell rm -rf $(mmtPathCA)))
	)

	$(eval $(call trace,processing docker::docker_prefix))
	$(if $(docker_prefix),
		$(eval $(call trace,prefixing $(mmtName)_TERMINATES with $(docker_prefix)))
		$(eval $(mmtName)_TERMINATES := $(docker_prefix)$($(mmtName)_TERMINATES))
		$(eval $(call trace,-> $(mmtName)_TERMINATES=$($(mmtName)_TERMINATES))))

	$(eval $(call trace,producing recipe content for $(mmtName)))
	$(if $(mmtCAp),
		$(eval $(call trace,adding commands to duplicate CA certs))
		$(eval mmtX1 := $$Qecho "(re-)Copying trust roots for $(mmtName)")
		$(eval mmtX2 := $$Qrm -f $(mmtPathCA)/*)
		$(eval mmtX3 := $$Qfind -L $(mmtCAp) \
			$(if $(mmtCAm),$(mmtCAm),-type f -name "*.crt") \
			-exec cp {} $(mmtPathCA) \;)
		$(eval mmtX := mmtX1 mmtX2 mmtX3)
	,
		$(eval $(call trace,no commands to duplicate CA certs))
		$(eval mmtX :=)
	)
	$(eval $(call trace,adding commands to build Dockerfile))
	$(eval mmtY1 := $$Qecho "(re-)Creating Dockerfile for $(mmtName)")
	$(eval mmtY2 := $$Qecho "\# Auto-generated by make_mariner_terminator" > $(mmtPath)/Dockerfile)
	$(eval mmtY3 := $$Qecho "RUN echo 'debconf debconf/frontend select Noninteractive' | debconf-set-selections" >> $(mmtPath)/Dockerfile)
	$(eval mmtY4 := $$Qecho "RUN apt-get update" >> $(mmtPath)/Dockerfile)
	$(eval mmtY5 := $$Qecho "RUN apt-get -y dist-upgrade" >> $(mmtPath)/Dockerfile)
	$(eval mmtY6 := $$Qecho "RUN apt-get install -y apt-utils" >> $(mmtPath)/Dockerfile)
	$(eval mmtY := mmtY1 mmtY2 mmtY3 mmtY4 mmtY5 mmtY6)
	$(if $(mmtCAp),
		$(eval mmtY7 := $$Qecho "RUN apt-get install -y ca-certificates" >> $(mmtPath)/Dockerfile)
		$(eval mmtY8 := $$Qecho "RUN mkdir -p $(mmtImgCA)" >> $(mmtPath)/Dockerfile)
		$(eval mmtY9 := $$Qfor i in `cd $(mmtPathCA) && ls`; do \)
		$(eval mmtY10 := echo "ADD CA-certs/$$$$$$$$i $(mmtImgCA)" >> $(mmtPath)/Dockerfile; \)
		$(eval mmtY11 := echo "RUN echo 'Mariner-injection/$$$$$$$$i' >> $(mmtEtcCA)" >> $(mmtPath)/Dockerfile; \)
		$(eval mmtY12 := done)
		$(eval mmtY13 := $$Qecho "RUN update-ca-certificates" >> $(mmtPath)/Dockerfile)
		$(eval mmtY += mmtY7 mmtY8 mmtY9 mmtY10 mmtY11 mmtY12 mmtY13)
	)

	$(eval $(call mkout_header,TERMINATOR $(mmtName) -> $(mmtExt)))
	$(eval $(call mkout_rule,
		$(mmtPath)/Dockerfile,
		$(TOP_DEPS) $(mariner_control_files),
		$(mmtX) $(mmtY)))

	$(eval IMAGES += $(mmtName))
	$(eval $(call trace,Adding $(mntName) to IMAGES -> $(IMAGES)))

	$(eval $(call trace,end make_mariner_terminator($1,$2)))
endef

# $1 = new layer (image) name. This will be created inside the crud directory
# $2 = base layer (image) name. We extend this one.
# $3 = path to features.
# $4 = desired feature (a relative path to $3, may include sub-directories)
#
# "Features" have two components, a path and a name. The names of features get
# added to _FEATURES attributes of images that have them, and we sometimes need
# to test for their presence. The hick, is that the name itself has directory
# name-spacing. E.g. we want to be able load the "debian/embed-me" feature from
# the "features" directory, not the "embed-me" feature from "features/debian".
# This is more of a problem for the feature implementations than the framework
# code here, but we facilitate by converting $3 (path) and $4 (name), which may
# both may contain directory separators, to the resulting basename and dirname,
# per the shell functions of the same name, and passing those as environment
# variables.
#
# We include the makefile for a desired feature, which is assumed to have an
# additional ".mk" suffix, and reside at a caller-specified path.
# Things are that are done _before_ the feature makefile is included;
# - checks that the base image has been defined.
# - checks that the new image hasn't been defined.
# - checks that the base image doesn't already have feature $(NAME).
# - creates a directory to store the new image definition and stores it in
#   $(NEW_IMAGE)_PATH.
# - sets $(NEW_IMAGE)_DOCKERFILE to $($(NEW_IMAGE)_PATH)/Dockerfile
#   but doesn't create the Dockerfile itself.
# - sets $(NEW_IMAGE)_EXTENDS to $(BASE_IMAGE).
# - $(NEW_IMAGE) has its FEATURES, ARGS_DOCKER_BUILD, and ARGS_DOCKER_RUN
#   attributes inherited from $(BASE_IMAGE).
# What the included feature makefile should then do;
# - verify that $(BASE_IMAGE)_FEATURES has any prerequisite features.
# - set up a dependency for the expected Dockerfile on any relevant source
#   files, and use that to (re)sync/(re)generate those files to the expected
#   location.
# - define the relevant attributes for $(NEW_IMAGE).
# What this function does after the feature makefile has been included;
# - marks the new image as having the desired feature.
# - adds the new image to the global IMAGES list.
#
# uniquePrefix: mfl
define make_feature_layer
	$(eval $(call trace,start make_feature_layer($1,$2,$3,$4)))
	$(eval mfl_NEW_IMAGE := $(strip $1))
	$(eval mfl_BASE_IMAGE := $(strip $2))
	$(eval mfl_PATH := $(strip $3))
	$(eval mfl_NAME := $(strip $4))
	$(eval mfl_FN := $(subst /,__,feature_$(mfl_NAME)))

	$(eval mfl_TMP := $(mfl_PATH)/$(mfl_NAME).mk)
	$(eval $(call trace,verify feature source exists))
	$(if $(shell stat $(mfl_TMP) > /dev/null 2>&1 && echo YES),,
		$(error "Bad: feature $(mfl_TMP) does not exist"))
	$(eval mfl_DIRNAME := $(shell dirname $(mfl_TMP)))

	$(eval $(call trace,verify old image is defined))
	$(eval $(call verify_in_list,mfl_BASE_IMAGE,IMAGES))
	$(eval $(call trace,verify new image is not defined))
	$(eval $(call verify_not_in_list,mfl_NEW_IMAGE,IMAGES))
	$(eval $(call trace,verify base image does not have the feature))
	$(eval $(call verify_not_in_list,mfl_NAME,$(mfl_BASE_IMAGE)_FEATURES))
	$(eval mflNewPath := $(DEFAULT_CRUD)/feature-$(mfl_NEW_IMAGE))
	$(eval $(call trace,created feature layer at $(mflNewPath)))
	$(if $(shell stat $(mflNewPath) > /dev/null 2>&1 && echo YES),,\
		$(if $(shell mkdir $(mflNewPath) > /dev/null 2>&1 && echo YES),,\
			$(error "Bad: failed to create $(mflNewPath)")))
	$(eval $(mfl_NEW_IMAGE)_EXTENDS := $(mfl_BASE_IMAGE))
	$(eval $(mfl_NEW_IMAGE)_PATH := $(mflNewPath))
	$(eval $(mfl_NEW_IMAGE)_DOCKERFILE := $(mflNewPath)/Dockerfile)
	$(eval $(mfl_NEW_IMAGE)_FEATURES := $($(mfl_BASE_IMAGE)_FEATURES))
	$(eval $(mfl_NEW_IMAGE)_ARGS_DOCKER_BUILD := $($(mfl_BASE_IMAGE)_ARGS_DOCKER_BUILD))
	$(eval $(mfl_NEW_IMAGE)_ARGS_DOCKER_RUN := $($(mfl_BASE_IMAGE)_ARGS_DOCKER_RUN))

	$(eval $(call trace,preparing to call the feature hook;))
	$(eval $(call trace, -> mfl_NEW_IMAGE=$(mfl_NEW_IMAGE)))
	$(eval $(call trace, -> mfl_BASE_IMAGE=$(mfl_BASE_IMAGE)))
	$(eval $(call trace, -> mfl_PATH=$(mfl_PATH)))
	$(eval $(call trace, -> mfl_NAME=$(mfl_NAME)))
	$(eval $(call trace, -> mfl_FN=$(mfl_FN)))
	$(eval $(call trace,verifying if the feature was loaded;))
	$(if $($(mfl_FN)_loaded),,
		$(error "Bad: $(mfl_FN) not loaded, did you include it?"))
	$(eval $(call trace, calling $(mfl_FN)))
	$(eval $(call $(mfl_FN),$(mfl_NEW_IMAGE),$(mfl_BASE_IMAGE),$(mfl_PATH)))

	$(eval $(call trace,post-processing feature $(mfl_NAME)))
	$(eval $(mfl_NEW_IMAGE)_FEATURES += $(mfl_NAME))
	$(eval IMAGES += $(mfl_NEW_IMAGE))

	$(eval $(call trace,end make_feature_layer($1,$2,$3,$4)))
endef
